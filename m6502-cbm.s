; TITLE BASIC M6502 8K VER 1.1 BY MICRO-SOFT

; SUBTTL        SWITCHES,MACROS.



ADDPRC=1                        ;FOR ADDITIONAL PRECISION.
RAMLOC=$0400
ROMLOC=$C000
LINLEN=40
BUFLEN=81
CQOPEN=$FFC0
CQCLOS=$FFC3
CQOIN=$FFC6             ;OPEN CHANNEL FOR INPUT
CQOOUT=$FFC9            ;FILL FOR COMMO.
CQCCHN=$FFCC
CQINCH=$FFCF            ;INCHR'S CALL TO GET A CHARACTER
OUTCH=$FFD2
CQLOAD=$FFD5
CQSAVE=$FFD8
CQVERF=$FFDB
CQSYS=$FFDE
ISCNTC=$FFE1
CZGETL=$FFE4            ;CALL POINT FOR "GET"
CQCALL=$FFE7            ;CLOSE ALL CHANNELS
CQTIMR=$008D
BUFPAG=2
BUF=256*BUFPAG
STKEND=507
CQSTAT=$0096
CQHTIM=$E844
CLMWID=10
PI=255                          ;VALUE OF PI CHARACTER FOR COMMODORE.
TRMPOS=$00C6

.MACRO DC STR
  .REPEAT .STRLEN(STR)-1,I
    .BYTE .STRAT(STR,I)
  .ENDREP
  .BYTE .STRAT(STR,.STRLEN(STR)-1) | $80
.ENDMACRO

.MACRO ACRLF
  .BYTE $0D, $0A
.ENDMACRO

.MACRO SYNCHK VALUE
  LDA #VALUE
  JSR SYNCHR
.ENDMACRO

.MACRO DT STR
  .BYTE STR
.ENDMACRO

.MACRO LDWD ADDRESS
  LDA ADDRESS+0
  LDY ADDRESS+1
.ENDMACRO

.MACRO LDWDI ADDRESS
  LDA #<(ADDRESS)
  LDY #>(ADDRESS)
.ENDMACRO

.MACRO LDWX ADDRESS
  LDA ADDRESS+0
  LDX ADDRESS+1
.ENDMACRO

.MACRO LDWXI ADDRESS
  LDA #<(ADDRESS)
  LDX #>(ADDRESS)
.ENDMACRO

.MACRO LDXY ADDRESS
  LDX ADDRESS+0
  LDY ADDRESS+1
.ENDMACRO

.MACRO LDXYI ADDRESS
  LDX #<(ADDRESS)
  LDY #>(ADDRESS)
.ENDMACRO

.MACRO STWD ADDRESS
  STA ADDRESS+0
  STY ADDRESS+1
.ENDMACRO

.MACRO STWX ADDRESS
  STA ADDRESS+0
  STx ADDRESS+1
.ENDMACRO

.MACRO STXY ADDRESS
  STX ADDRESS+0
  STY ADDRESS+1
.ENDMACRO

.MACRO CLR ADDRESS
  LDA #0
  STA ADDRESS
.ENDMACRO

.MACRO COM ADDRESS
  LDA ADDRESS
  EOR #$FF
  STA ADDRESS
.ENDMACRO

.MACRO PULWD ADDRESS
  PLA
  STA ADDRESS+0
  PLA
  STA ADDRESS+1
.ENDMACRO

.MACRO PSHWD ADDRESS
  LDA ADDRESS+1
  PHA
  LDA ADDRESS+0
  PHA
.ENDMACRO

.MACRO JEQ ADDRESS
  BNE *+5
  JMP ADDRESS
.ENDMACRO

.MACRO JNE ADDRESS
  BEQ *+5
  JMP ADDRESS
.ENDMACRO

.MACRO BCCA ADDRESS
  BCC ADDRESS
.ENDMACRO

.MACRO BCSA ADDRESS
  BCS ADDRESS
.ENDMACRO

.MACRO BEQA ADDRESS
  BEQ ADDRESS
.ENDMACRO

.MACRO BNEA ADDRESS
  BNE ADDRESS
.ENDMACRO

.MACRO BMIA ADDRESS
  BMI ADDRESS
.ENDMACRO

.MACRO BPLA ADDRESS
  BPL ADDRESS
.ENDMACRO

.MACRO BVCA ADDRESS
  BVC ADDRESS
.ENDMACRO

.MACRO BVSA ADDRESS
  BVS ADDRESS
.ENDMACRO

.MACRO INCW ADDRESS
  .LOCAL @SKIP
  INC ADDRESS+0
  BNE @SKIP
  INC ADDRESS+1
  @SKIP:
.ENDMACRO

.MACRO SKIP1 ADDRESS
  .BYTE $24 ; BIT ZERO PAGE
.ENDMACRO

.MACRO SKIP2 ADDRESS
  .BYTE $2C ; BIT ABS
.ENDMACRO

; SUBTTL        INTRODUCTION AND COMPILATION PARAMETERS.

.FEATURE c_comments

/*

--------- ---- -- ---------
COPYRIGHT 1976 BY MICROSOFT
--------- ---- -- ---------
7/27/78 FIXED BUG WHERE FOR VARIABLE AT BYTE FF MATCHED RETURN SEARCHING
        FOR GOSUB ENTRY ON STACK IN FNDFOR CALL BY CHANGING STA FORPNT
        TO STA FORPNT+1. THIS IS A SERIOUS BUG IN ALL VERSIONS.
7/27/78 FIXED BUG AT NEWSTT UNDER IFN BUFPAG WHEN CHECK OF CURLIN
        WAS DONE BEFORE CURLIN SET UP SO INPUT RETRIES OF FIRST STATEMENT
        WAS GIVING SYNTAX ERROR INSTEAD OF REDO FROM START (CODE WAS 12/1/77 FIX)
7/1/78  SAVED A FEW BYTES IN INIT FOR COMMODORE (14)
7/1/78 FIXED BUG WHERE REPLACING A LINE OVERFLOWING MEMORY LEFT LINKS
        IN A BAD STATE. (CODE AT NODEL AND FINI) BUG#4
7/1/78 FIXED BUG WHERE GARBAGE COLLECTION NEVER(!) COLLECTS TEMPS
        (STY GRBPNT  AT FNDVAR, LDA GRBPNT ORA GRBPNT+1 AT GRBPAS)
        THIS WAS COMMODORE BUG #2
7/1/78 FIXED BUG WHERE DELETE/INSERT OF LINE COULD CAUSE A GARBAGE COLLECTION WITH BAD VARTAB IF OUT OF MEMORY
         (LDWD MEMSIZ STWD FRETOP=JSR RUNC CLC ALSO AT NODEL)
3/9/78 EDIT TO FIX COMMO TRMPOS AND CHANGE LEFT$ AND RIGHT$ TO ALLOW A SECOND ARGUMENT OF 0 AND RETURN A NULL STRING
2/25/78 FIXED BUG THAT INPFLG WAS SET WRONG WHEN BUFPAG.NE.0
        INCREASED NUMLEV FROM 19 TO 23
2/11/78 DISALLOWED SPACES IN RESERVED WORDS. PUT IN SPECIAL CHECK FOR "GO TO"
2/11/78 FIXED BUG WHERE ROUNDING OF THE FAC BEFORE PUSHING COULD CAUSE A STRING POINTER
        IN THE FAC TO BE INCREMENTED
1/24/78 fixed problem where user defined function undefined check fix was smashing error number in [x]
12/1/77 FIXED PROBLEM WHERE PEEK WAS SMASHING (POKER) CAUSING POKE OF PEEK TO FAIL
12/1/77 FIXED PROBLEM WHERE PROBLEM WITH VARTXT=LINNUM=BUF-2 CAUSING BUF-1 COMMA TO DISAPPEAR
12/1/77 FIXED BUFPAG.NE.0 PROBLEM AT NEWSTT AND STOP : CODE WAS STILL
        ASSUMING TXTPTR+1.EQ.0 IFF STATEMENT WAS DIRECT
*/
NUMLEV=23                       ;NUMBER OF STACK LEVELS RESERVED
                                ;BY AN EXPLICIT CALL TO "GETSTK".
STRSIZ=3                        ;# OF LOCS PER STRING DESCRIPTOR.
NUMTMP=3                        ;NUMBER OF STRING TEMPORARIES.
CONTW=15                        ;CHARACTER TO SUPPRESS OUTPUT.

; SUBTTL        SOME EXPLANATION.
/*

M6502 BASIC CONFIGURES BASIC AS FOLLOWS

LOW LOCATIONS
        PAGE    ZERO

                STARTUP:
                INITIALLY A JMP TO INITIALIZATION CODE BUT
                CHANGED TO A JMP TO "READY".
                RESTARTING THE MACHINE AT LOC 0 DURING PROGRAM
                EXECUTION CAN LEAVE THINGS MESSED UP.

                LOC OF FAC TO INTEGER AND INTEGER TO FAC 
                ROUTINES.

                "DIRECT" MEMORY:
                THESE ARE THE MOST COMMONLY USED LOCATIONS.
                THEY HOLD BOOKKEEPING INFO AND ALL OTHER
                FREQUENTLY USED INFORMATION.
                ALL TEMPORARIES, FLAGS, POINTERS, THE BUFFER AREA,
                THE FLOATING ACCUMULATOR, AND ANYTHING ELSE THAT
                IS USED TO STORE A CHANGING VALUE SHOULD BE LOCATED
                IN THIS AREA. CARE MUST BE MADE IN MOVING LOCATIONS
                IN THIS AREA SINCE THE JUXTAPOSITION OF TWO LOCATIONS
                IS OFTEN DEPENDED UPON.

                STILL IN RAM WE HAVE THE BEGINNING OF THE "CHRGET"
                SUBROUTINE. IT IS HERE SO [TXTPTR] CAN BE THE
                EXTENDED ADDRESS OF A LOAD INSTRUCTION.
                THIS SAVES HAVING TO BOTHER ANY REGISTERS.

        PAGE    ONE
                THE STACK.

        STORAGE PAGE TWO AND ON
                IN RAM VERSIONS THESE DATA STRUCTURES COME AT THE
                END OF BASIC. IN ROM VERSON THEY ARE AT RAMLOC WHICH
                CAN EITHER BE ABOVE OR BELOW ROMLOC, WHICH IS WHERE
                BASIC ITSELF RESIDES.

                                A ZERO.
                [TXTTAB]        POINTER TO NEXT LINE'S POINTER.
                                LINE # OF THIS LINE (2 BYTES).
                                CHARACTERS ON THIS LINE.
                                ZERO.
                                POINTER AT NEXT LINE'S POINTER
                                        (POINTED TO BY THE ABOVE POINTER).
                                ... REPEATS ...
                LAST LINE:      POINTER AT ZERO POINTER.
                                LINE # OF THIS LINE.
                                CHARACTERS ON THIS LINE.
                                ZERO.
                                DOUBLE ZERO (POINTED TO BY THE ABOVE POINTER).
                [VARTAB]        SIMPLE VARIABLES. 6 BYTES PER VALUE.
                                2 BYTES GIVE THE NAME, 4 BYTES THE VALUE.
                                ... REPEATS ...
                [ARYTAB]        ARRAY VARIABLES. 2 BYTES NAME, 2 BYTE
                                LENGTH, NUMBER OF DIMENSIONS , EXTENT OF
                                EACH DIMENSION (2BYTES/), VALUES
                                ... REPEATS ...
                [STREND]        FREE SPACE.
                                ... REPEATS ...
                [FRETOP]        STRING SPACE IN USE.
                                ... REPEATS ...
                [MEMSIZ]        HIGHEST MACHINE LOCATION.
                                UNUSED EXCEPT BY THE VAL FUNCTION.

                ROM -- CONSTANTS AND CODE.

        FUNCTION DISPATCH ADDRESSES (AT ROMLOC)
                "FUNDSP" CONTAINS THE ADDRESSES OF THE
                FUNCTION ROUTINES IN THE ORDER OF THE
                FUNCTION NAMES IN THE CRUNCH LIST.
                THE FUNCTIONS THAT TAKE MORE THAN ONE ARGUMENT
                ARE AT THE END. SEE THE EXPLANATION AT "ISFUN".

        THE OPERATOR LIST
                THE "OPTAB" LIST CONTAINS AN OPERATOR'S PRECEDENCE
                FOLLOWED BY THE ADDRESS OF THE ROUTINE TO PERFORM
                THE OPERATION. THE INDEX INTO THE
                OPERATOR LIST IS MADE BY SUBTRACTING OFF THE CRUNCH VALUE
                OF THE LOWEST NUMBERED OPERATOR. THE ORDER
                OF OPERATORS IN THE CRUNCH LIST AND IN "OPTAB" IS IDENTICAL.
                THE PRECEDENCES ARE ARBITRARY EXCEPT FOR THEIR
                COMPARATIVE SIZES. NOTE THAT THE PRECEDENCE FOR
                UNARY OPERATORS SUCH AS "NOT" AND NEGATION ARE
                SETUP SPECIALLY WITHOUT USING THE LIST.

        THE RESERVED WORD OR CRUNCH LIST
                WHEN A COMMAND OR PROGRAM LINE IS TYPED IN
                IT IS STORED IN "BUF". AS SOON AS THE WHOLE LINE
                HAS BEEN TYPED IN ("INLIN" RETURNS) "CRUNCH" IS
                CALLED TO CONVERT ALL RESERVED WORDS TO THEIR
                CRUNCHED VALUES. THIS REDUCES THE SIZE OF THE 
                PROGRAM AND SPEEDS UP EXECUTION BY ALLOWING
                LIST DISPATCHES TO PERFORM FUNCTIONS, STATEMENTS,
                AND OPERATIONS. THIS IS BECAUSE ALL THE STATEMENT
                NAMES ARE STORED CONSECUTIVELY IN THE CRUNCH LIST.
                WHEN A MATCH IS FOUND BETWEEN A STRING
                OF CHARACTERS AND A WORD IN THE CRUNCH LIST
                THE ENTIRE TEXT OF THE MATCHED WORD IS TAKEN OUT OF
                THE INPUT LINE AND A RESERVED WORD TOKEN IS PUT
                IN ITS PLACE. A RESERVED WORD TOKEN IS ALWAYS EQUAL
                TO OCTAL 200 PLUS THE POSITION OF THE MATCHED WORD
                IN THE CRUNCH LIST.

        STATEMENT DISPATCH ADDRESSES
                WHEN A STATEMENT IS TO BE EXECUTED, THE FIRST
                CHARACTER OF THE STATEMENT IS EXAMINED
                TO SEE IF IT IS LESS THAN THE RESERVED
                WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT NAME.
                IF SO, THE "LET" CODE IS CALLED TO
                TREAT THE STATEMENT AS AN ASSIGNMENT STATEMENT.
                OTHERWISE A CHECK IS MADE TO MAKE SURE THE
                RESERVED WORD NUMBER IS NOT TOO LARGE TO BE A
                STATEMENT TYPE NUMBER. IF NOT THE ADDRESS
                TO DISPATCH TO IS FETCHED FROM "STMDSP" (THE STATEMENT
                DISPATCH LIST) USING THE RESERVED WORD
                NUMBER FOR THE STATEMENT TO CALCULATE AN INDEX INTO
                THE LIST.

        ERROR MESSAGES
                WHEN AN ERROR CONDITION IS DETECTED,
                [ACCX] MUST BE SET UP TO INDICATE WHICH ERROR
                MESSAGE IS APPROPRIATE AND A BRANCH MUST BE MADE
                TO "ERROR". THE STACK WILL BE RESET AND ALL
                PROGRAM CONTEXT WILL BE LOST. VARIABLES
                VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.
                ONLY THE VALUE OF [ACCX] IS IMPORTANT WHEN
                THE BRANCH IS MADE TO ERROR. [ACCX] IS USED AS AN
                INDEX INTO "ERRTAB" WHICH GIVES THE TWO
                CHARACTER ERROR MESSAGE THAT WILL BE PRINTED ON THE
                USER'S TERMINAL.


        TEXTUAL MESSAGES
                CONSTANT MESSAGES ARE STORED HERE. UNLESS
                THE CODE TO CHECK IF A STRING MUST BE COPIED
                IS CHANGED THESE STRINGS MUST BE STORED ABOVE
                PAGE ZERO, OR ELSE THEY WILL BE COPIED BEFORE
                THEY ARE PRINTED.

        FNDFOR  
                MOST SMALL ROUTINES ARE FAIRLY SIMPLE
                AND ARE DOCUMENTED IN PLACE. "FNDFOR" IS
                USED FOR FINDING "FOR" ENTRIES ON
                THE STACK. WHENEVER A "FOR" IS EXECUTED, A
                16-BYTE ENTRY IS PUSHED ONTO THE STACK.
                BEFORE THIS IS DONE, HOWEVER, A CHECK
                MUST BE MADE TO SEE IF THERE
                ARE ANY "FOR" ENTRIES ALREADY ON THE STACK
                FOR THE SAME LOOP VARIABLE. IF SO, THAT "FOR" ENTRY
                AND ALL OTHER "FOR" ENTRIES THAT WERE MADE AFTER IT
                ARE ELIMINATED FROM THE STACK. THIS IS SO A
                PROGRAM THAT JUMPS OUT OF THE MIDDLE
                OF A "FOR" LOOP AND THEN RESTARTS THE LOOP AGAIN
                AND AGAIN WON'T USE UP 18 BYTES OF STACK
                SPACE EVERY TIME. THE "NEXT" CODE ALSO
                CALLS "FNDFOR" TO SEARCH FOR A "FOR" ENTRY WITH
                THE LOOP VARIABLE IN
                THE "NEXT". AT WHATEVER POINT A MATCH IS FOUND
                THE STACK IS RESET. IF NO MATCH IS FOUND A
                "NEXT WITHOUT FOR"  ERROR OCCURS. GOSUB EXECUTION
                ALSO PUTS A 5-BYTE ENTRY ON STACK.
                WHEN A RETURN IS EXECUTED "FNDFOR" IS
                CALLED WITH A VARIABLE POINTER THAT CAN'T
                BE MATCHED. WHEN "FNDFOR" HAS RUN
                THROUGH ALL THE "FOR" ENTRIES ON THE STACK  
                IT RETURNS AND THE RETURN CODE MAKES
                SURE THE ENTRY THAT WAS STOPPED
                ON IS A GOSUB ENTRY. THIS ASSURES THAT
                IF YOU GOSUB TO A SECTION OF CODE
                IN WHICH A FOR LOOP IS ENTERED BUT NEVER
                EXITED THE RETURN WILL STILL BE
                ABLE TO FIND THE MOST RECENT
                GOSUB ENTRY. THE "RETURN" CODE ELIMINATES THE
                "GOSUB" ENTRY AND ALL "FOR" ENTRIES MADE AFTER
                THE GOSUB ENTRY.

        NON-RUNTIME STUFF
                THE CODE TO INPUT A LINE, CRUNCH IT, GIVE ERRORS,
                FIND A SPECIFIC LINE IN THE PROGRAM,
                PERFORM A "NEW", "CLEAR", AND "LIST" ARE
                ALL IN THIS AREA. GIVEN THE EXPLANATION OF
                PROGRAM STORAGE SET FORTH ABOVE, THESE ARE
                ALL STRAIGHTFORWARD.

        NEWSTT
                WHENEVER A STATEMENT FINISHES EXECUTION IT
                DOES A "RTS" WHICH TAKES
                EXECUTION BACK TO "NEWSTT". STATEMENTS THAT
                CREATE OR LOOK AT SEMI-PERMANENT STACK ENTRIES
                MUST GET RID OF THE RETURN ADDRESS OF "NEWSTT" AND
                JMP TO "NEWSTT" WHEN DONE. "NEWSTT" ALWAYS
                CHRGETS THE FIRST CHARACTER AFTER THE STATEMENT
                NAME BEFORE DISPATCHING. WHEN RETURNING
                BACK TO "NEWSTT" THE ONLY THING THAT
                MUST BE SET UP IS THE TEXT POINTER IN
                "TXTPTR". "NEWSTT" WILL CHECK TO MAKE SURE
                "TXTPTR" IS POINTING TO A STATEMENT TERMINATOR.
                IF A STATEMENT SHOULDN'T BE PERFORMED UNLESS
                IT IS PROPERLY FORMATTED (I.E. "NEW") IT CAN
                SIMPLY DO A RETURN AFTER READING ALL OF
                ITS ARGUMENTS. SINCE THE ZERO FLAG
                BEING OFF INDICATES THERE IS NOT
                A STATEMENT TERMINATOR "NEWSTT" WILL
                DO THE JMP TO THE "SYNTAX ERROR"
                ROUTINE. IF A STATEMENT SHOULD BE STARTED
                OVER IT CAN DO LDWD OLDTXT, STWD TXTPTR RTS SINCE THE TEXT PNTR
                AT "NEWSTT" IS ALWAYS STORED IN "OLDTXT".
                THE ^C CODE STORES [CURLIN] (THE
                CURRENT LINE NUMBER) IN "OLDLIN" SINCE THE ^C CHECK
                IS MADE BEFORE THE STATEMENT POINTED TO IS
                EXECUTED. "STOP" AND "END" STORE THE TEXT POINTER
                FROM "TXTPTR", WHICH POINTS AT THEIR TERMINATING
                CHARACTER, IN "OLDTXT".

        STATEMENT CODE
                THE INDIVIDUAL STATEMENT CODE COMES
                NEXT. THE APPROACH USED IN EXECUTING EACH
                STATEMENT IS DOCUMENTED IN THE STATEMENT CODE
                ITSELF.

        FRMEVL, THE FORMULA EVALUATOR
                GIVEN A TEXT POINTER POINTING TO THE STARTING
                CHARACTER OF A FORMULA, "FRMEVL"
                EVALUATES THE FORMULA AND LEAVES
                THE VALUE IN THE FLOATING ACCUMULATOR (FAC).
                "TXTPTR" IS RETURNED POINTING TO THE FIRST CHARACTER
                THAT COULD NOT BE INTERPRETED AS PART OF THE
                FORMULA. THE ALGORITHM USES THE STACK
                TO STORE TEMPORARY RESULTS:

                        0. PUT A DUMMY PRECEDENCE OF ZERO ON
                                THE STACK.
                        1. READ LEXEME (CONSTANT,FUNCTION,
                                VARIABLE,FORMULA IN PARENS)
                                AND TAKE THE LAST PRECEDENCE VALUE
                                OFF THE STACK.
                        2. SEE IF THE NEXT CHARACTER IS AN OPERATOR.
                                IF NOT, CHECK PREVIOUS ONE. THIS MAY CAUSE
                                OPERATOR APPLICATION OR AN ACTUAL
                                RETURN FROM "FRMEVL".
                        3. IF IT IS, SEE WHAT PRECEDENCE IT HAS
                                AND COMPARE IT TO THE PRECEDENCE
                                OF THE LAST OPERATOR ON THE STACK.
                        4. IF = OR LESS REMEMBER THE OPERATOR
                                POINTER OF THIS OPERATOR
                                AND BRANCH TO "QCHNUM" TO CAUSE
                                APPLICATION OF THE LAST OPERATOR.
                                EVENTUALLY RETURN TO STEP 2
                                BY RETURNING TO JUST AFTER "DOPREC".
                        5. IF GREATER PUT THE LAST PRECEDENCE
                                BACK ON, SAVE THE OPERATOR ADDRESS,
                                CURRENT TEMPORARY RESULT,
                                AND PRECEDENCE AND RETURN TO STEP 1.

                RELATIONAL OPERATORS ARE ALL HANDLED THROUGH
                A COMMON ROUTINE. SPECIAL
                CARE IS TAKEN TO DETECT TYPE MISMATCHES SUCH AS 3+"F".

        EVAL -- THE ROUTINE TO READ A LEXEME
                "EVAL" CHECKS FOR THE DIFFERENT TYPES OF
                ENTITIES IT IS SUPPOSED TO DETECT.
                LEADING PLUSES ARE IGNORED,
                DIGITS AND "." CAUSE "FIN" (FLOATING INPUT)
                TO BE CALLED. FUNCTION NAMES CAUSE THE
                FORMULA INSIDE THE PARENTHESES TO BE EVALUATED
                AND THE FUNCTION ROUTINE TO BE CALLED. VARIABLE
                NAMES CAUSE "PTRGET" TO BE CALLED TO GET A POINTER
                TO THE VALUE, AND THEN THE VALUE IS PUT INTO
                THE FAC. AN OPEN PARENTHESIS CAUSES "FRMEVL"
                TO BE CALLED (RECURSIVELY), AND THE ")" TO
                BE CHECKED FOR. UNARY OPERATORS (NOT AND
                NEGATION)  PUT THEIR PRECEDENCE ON THE STACK
                AND ENTER FORMULA EVALUATION AT STEP 1, SO
                THAT EVERYTHING UP TO AN OPERATOR GREATER THAN
                THEIR PRECEDENCE OR THE END OF THE FORMULA
                WILL BE EVALUATED.

        DIMENSION AND VARIABLE SEARCHING
                SPACE IS ALLOCATED FOR VARIABLES AS THEY ARE
                ENCOUNTERED. THUS "DIM" STATEMENTS MUST BE
                EXECUTED TO HAVE EFFECT. 6 BYTES ARE ALLOCATED
                FOR EACH SIMPLE VARIABLE, WHETHER IT IS A STRING,
                NUMBER OR USER DEFINED FUNCTION. THE FIRST TWO
                BYTES GIVE THE NAME OF THE VARIABLE AND THE LAST FOUR
                GIVE ITS VALUE. [VARTAB] GIVES THE FIRST LOCATION
                WHERE A SIMPLE VARIABLE NAME IS FOUND AND [ARYTAB]
                GIVES THE LOCATION TO STOP SEARCHING FOR SIMPLE
                VARIABLES. A "FOR" ENTRY HAS A TEXT POINTER
                AND A POINTER TO A VARIABLE VALUE SO NEITHER
                THE PROGRAM OR THE SIMPLE VARIABLES CAN BE
                MOVED WHILE THERE ARE ACTIVE "FOR" ENTRIES ON THE STACK.
                USER DEFINED FUNCTION VALUES ALSO CONTAIN
                POINTERS INTO SIMPLE VARIABLE SPACE SO NO USER-DEFINED
                FUNCTION VALUES CAN BE RETAINED IF SIMPLE VARIABLES
                ARE MOVED. ADDING A SIMPLE VARIABLE IS JUST
                ADDING SIX TO [ARYTAB] AND [STREND], BLOCK TRANSFERING
                THE ARRAY VARIABLES UP BY SIX AND MAKING SURE THE
                NEW [STREND] IS NOT TOO CLOSE TO THE STRINGS.
                THIS MOVEMENT OF ARRAY VARIABLES MEANS
                THAT NO POINTER TO AN ARRAY WILL STAY VALID WHEN
                NEW SIMPLE VARIABLES CAN BE ENCOUNTERED. THIS IS
                WHY ARRAY VARIABLES ARE NOT ALLOWED FOR "FOR"
                LOOP VARIABLES. SETTING UP A NEW ARRAY VARIABLE
                MERELY INVOLVES BUILDING THE DESCRIPTOR,
                UPDATING [STREND], AND MAKING SURE THERE IS
                STILL ENOUGH ROOM BETWEEN [STREND] AND STRING SPACE.
                "PTRGET", THE ROUTINE WHICH RETURNS A POINTER
                TO A VARIABLE VALUE, HAS TWO IMPORTANT FLAGS. ONE IS
                "DIMFLG" WHICH INDICATES WHETHER "DIM" CALLED "PTRGET"
                OR NOT. IF SO, NO PRIOR ENTRY FOR THE VARIABLE IN
                QUESTION SHOULD BE FOUND, AND THE INDEX INDICATES
                HOW MUCH SPACE TO SET ASIDE. SIMPLE VARIABLES CAN
                BE "DIMENSIONED", BUT THE ONLY EFFECT WILL BE TO
                SET ASIDE SPACE FOR THE VARIABLE IF IT HASN'T BEEN
                ENCOUNTERED YET. THE OTHER IMPORTANT FLAG IS "SUBFLG"
                WHICH INDICATES WHETHER A SUBSCRIPTED VARIABLE SHOULD BE
                ALLOWED IN THE CURRENT CONTEXT. IF [SUBFLG] IS NON-ZERO
                THE OPEN PARENTHESIS FOR A SUBSCRIPTED VARIABLE
                WILL NOT BE SCANNED BY "PTRGET", AND "PTRGET" WILL RETURN
                WITH A TEXT POINTER POINTING TO THE "(", IF
                THERE WAS ONE.
        STRINGS
                IN THE VARIABLE TABLES STRINGS ARE STORED JUST LIKE
                NUMERIC VARIABLES. SIMPLE STRINGS HAVE THREE VALUE
                BYTES WHICH ARE INITIALIZED TO ALL ZEROS (WHICH
                REPRESENTS THE NULL STRING). THE ONLY DIFFERENCE
                IN HANDLING IS THAT WHEN "PTRGET" SEES A "$" AFTER THE
                NAME OF A VARIABLE, "PTRGET" SETS [VALTYP]
                TO NEGATIVE ONE AND TURNS
                ON THE MSB (MOST-SIGNIFIGANT-BIT) OF THE VALUE OF
                THE FIRST CHARACTER OF THE VARIABLE NAME.
                HAVING THIS BIT ON IN THE NAME OF THE VARIABLE ENSURES
                THAT THE SEARCH ROUTINE WILL NOT MATCH
                'A' WITH 'A$' OR 'A$' WITH 'A'. THE MEANING OF
                THE THREE VALUE BYTES ARE:
                        LOW
                                LENGTH OF THE STRING
                                LOW 8 BITS
                                HIGH 8 BITS  OF THE ADDRESS
                                        OF THE CHARACTERS IN THE
                                        STRING IF LENGTH.NE.0.
                                        MEANINGLESS OTHERWISE.
                        HIGH
                THE VALUE OF A STRING VARIABLE (THESE 3 BYTES)
                IS CALLED THE STRING DESCRIPTOR TO DISTINGUISH
                IT FROM THE ACTUAL STRING DATA. WHENEVER A
                STRING CONSTANT IS ENCOUNTERED IN A FORMULA OR AS
                PART OF AN INPUT STRING, OR AS PART OF DATA, "STRLIT"
                IS CALLED, CAUSING A DESCRIPTOR TO BE BUILT FOR
                THE STRING. WHEN ASSIGNMENT IS MADE TO A STRING POINTING INTO
                "BUF" THE VALUE IS COPIED INTO STRING SPACE SINCE [BUF]
                IS ALWAYS CHANGING.

                STRING FUNCTIONS AND THE ONE STRING OPERATOR "+"
                ALWAYS RETURN THEIR VALUES IN STRING SPACE.
                ASSIGNING A STRING A CONSTANT VALUE IN A PROGRAM
                THROUGH A "READ" OR ASSIGNMENT STATEMENT
                WILL NOT USE ANY STRING SPACE SINCE
                THE STRING DESCRIPTOR  WILL POINT INTO THE
                PROGRAM ITSELF. IN GENERAL, COPYING IS DONE
                WHEN A STRING VALUE IS IN "BUF", OR IT IS IN STRING
                SPACE AND THERE IS AN ACTIVE POINTER TO IT.
                THUS F$=G$ WILL CAUSE COPYING IF G$ HAS ITS
                STRING DATA IN STRING SPACE. F$=CHR$(7)
                WILL USE ONE BYTE OF STRING SPACE TO STORE THE
                NEW ONE CHARACTER STRING CREATED BY "CHR$", BUT
                THE ASSIGNMENT ITSELF WILL CAUSE NO COPYING SINCE
                THE ONLY POINTER AT THE NEW STRING IS A
                TEMPORARY DESCRIPTOR CREATED BY "FRMEVL" WHICH WILL
                GO AWAY AS SOON AS THE ASSIGNMENT IS DONE.
                IT IS THE NATURE OF GARBAGE COLLECTION THAT
                DISALLOWS HAVING TWO STRING DESCRIPTORS POINT TO THE SAME
                AREA IN STRING SPACE. STRING FUNCTIONS AND OPERATORS
                MUST PROCEED AS FOLLOWS:
                        1) FIGURE OUT THE LENGTH OF THEIR RESULT.

                        2) CALL "GETSPA" TO FIND SPACE FOR THEIR
                        RESULT. THE ARGUMENTS TO THE FUNCTION
                        OR OPERATOR MAY CHANGE SINCE GARBAGE COLLECTION
                        MAY BE INVOKED. THE ONLY THING THAT CAN
                        BE SAVED DURING THE CALL TO "GETSPA" IS A POINTER
                        TO THE DESCRIPTORS OF THE ARGUMENTS.
                        3) CONSTRUCT THE RESULT DESCRIPTOR IN "DSCTMP".
                        "GETSPA" RETURNS THE LOCATION OF THE AVAILABLE
                        SPACE.
                        4) CREATE THE NEW VALUE BY COPYING PARTS
                        OF THE ARGUMENTS OR WHATEVER.
                        5) FREE UP THE ARGUMENTS BY CALLING "FRETMP".
                        6) JUMP TO "PUTNEW" TO GET THE DESCRIPTOR IN
                        "DSCTMP" TRANSFERRED INTO A NEW STRING TEMPORARY.

                THE REASON FOR STRING TEMPORARIES IS THAT GARBAGE
                COLLECTION HAS TO KNOW ABOUT ALL ACTIVE STRING DESCRIPTORS
                SO IT KNOWS WHAT IS AND ISN'T IN USE. STRING TEMPORARIES ARE
                USED TO STORE THE DESCRIPTORS OF STRING EXPRESSIONS.
                
                INSTEAD OF HAVING AN ACTUAL VALUE STORED IN THE
                FAC, AND HAVING THE VALUE OF A TEMPORARY RESULT
                BEING SAVED ON THE STACK, AS HAPPENS WITH NUMERIC
                VARIABLES, STRINGS HAVE THE POINTER TO A STRING DESCRIPTOR
                STORED IN THE FAC, AND IT IS THIS POINTER
                THAT GETS SAVED ON THE STACK BY FORMULA EVALUATION.
                STRING FUNCTIONS CANNOT FREE THEIR ARGUMENTS UP RIGHT
                AWAY SINCE "GETSPA" MAY FORCE
                GARBAGE COLLECTION AND THE ARGUMENT STRINGS
                MAY BE OVER-WRITTEN SINCE GARBAGE COLLECTION
                WILL NOT BE ABLE TO FIND AN ACTIVE POINTER TO
                THEM. FUNCTION AND OPERATOR RESULTS ARE BUILT IN
                "DSCTMP" SINCE STRING TEMPORARIES ARE ALLOCATED
                (PUTNEW) AND DEALLOCATED (FRETMP) IN A FIFO ORDERING
                (I.E. A STACK) SO THE NEW TEMPORARY CANNOT
                BE SET UP UNTIL THE OLD ONE(S) ARE FREED. TRYING
                TO BUILD A RESULT IN A TEMPORARY AFTER
                FREEING UP THE ARGUMENT TEMPORARIES COULD RESULT
                IN ONE OF THE ARGUMENT TEMPORARIES BEING OVERWRITTEN
                TOO SOON BY THE NEW RESULT.

                STRING SPACE IS ALLOCATED AT THE VERY TOP
                OF MEMORY. "MEMSIZ" POINTS BEYOND THE LAST LOCATION OF
                STRING SPACE. STRINGS ARE STORED IN HIGH LOCATIONS
                FIRST. WHENEVER STRING SPACE IS ALLOCATED (GETSPA).
                [FRETOP], WHICH IS INITIALIZED TO [MEMSIZ], IS UPDATED
                TO GIVE THE HIGHEST LOCATION IN STRING SPACE
                THAT IS NOT IN USE. THE RESULT IS THAT
                [FRETOP] GETS SMALLER AND SMALLER, UNTIL SOME
                ALLOCATION WOULD MAKE [FRETOP] LESS THAN OR EQUAL TO
                [STREND]. THIS MEANS STRING SPACE HAS RUN INTO THE
                THE ARRAYS AND THAT GARBAGE COLLECTION MUST BE CALLED.

                GARBAGE COLLECTION:
                        0. [MINPTR]=[STREND] [FRETOP]=[MEMSIZ]
                        1. [REMMIN]=0
                        2. FOR EACH STRING DESCRIPTOR
                        (TEMPORARIES, SIMPLE STRINGS, STRING ARRAYS)
                        IF THE STRING IS NOT NULL AND ITS POINTER IS
                        .GT.MINPTR AND .LT.FRETOP,
                        [MINPTR]=THIS STRING DESCRIPTOR'S POINTER,
                        [REMMIN]=POINTER AT THIS STRING DESCRIPTOR.
                        END.
                        3. IF REMMIN.NE.0 (WE FOUND AN UNCOLLECTED STRING),
                        BLOCK TRANSFER THE STRING DATA POINTED
                        TO IN THE STRING DESCRIPTOR POINTED TO BY "REMMIN"
                        SO THAT THE LAST BYTE OF STRING DATA IS AT
                        [FRETOP]. UPDATE [FRETOP] SO THAT IT
                        POINTS TO THE LOCATION JUST BELOW THE ONE
                        THE STRING DATA WAS MOVED INTO. UPDATE
                        THE POINTER IN THE DESCRIPTOR SO IT POINTS
                        TO THE NEW LOCATION OF THE STRING DATA.
                        GO TO STEP 1.

                AFTER CALLING GARBAGE COLLECTION "GETSPA" AGAIN CHECKS
                TO SEE IF [ACCA] CHARACTERS ARE AVAILABLE BETWEEN
                [STREND] AND [FRETOP]; IF NOT, AN "OUT OF STRING"
                ERROR IS INVOKED.

        MATH PACKAGE
                THE MATH PACKAGE CONTAINS FLOATING INPUT (FIN),
                FLOATING OUTPUT (FOUT), FLOATING COMPARE (FCOMP)
                ... AND ALL THE NUMERIC OPERATORS AND FUNCTIONS.
                THE FORMATS, CONVENTIONS AND ENTRY POINTS ARE ALL
                DESCRIBED IN THE MATH PACKAGE ITSELF.

        INIT -- THE INITIALIZATION ROUTINE
                THE AMOUNT OF MEMORY,
                TERMINAL WIDTH, AND WHICH FUNCTIONS TO BE RETAINED
                ARE ASCERTAINED FROM THE USER. A ZERO IS PUT DOWN
                AT THE FIRST LOCATION NOT USED BY THE MATH-PACKAGE
                AND [TXTTAB] IS SET UP TO POINT AT THE NEXT LOCATION.
                THIS DETERMINES WHERE PROGRAM STORAGE WILL START.
                SPECIAL CHECKS ARE MADE TO MAKE SURE
                ALL QUESTIONS IN "INIT" ARE ANSWERED REASONABLY, SINCE
                ONCE "INIT" FINISHES, THE LOCATIONS IT USES ARE
                USED FOR PROGRAM STORAGE. THE LAST THING "INIT" DOES IS
                CHANGE LOCATION ZERO TO BE A JUMP TO "READY" INSTEAD
                OF "INIT". ONCE THIS IS DONE THERE IS NO WAY TO RESTART
                "INIT".
HIGH LOCATIONS

*/
; SUBTTL        PAGE ZERO.
.SEGMENT "ZEROPAGE"
                                ;ROUTINE TO CONVERT [Y,A] TO A FLOATING
                                ;POINT NUMBER IN THE FAC.
USRPOK: JMP     FCERR           ;SET UP ORIG BY INIT.
;
; THIS IS THE "VOLATILE" STORAGE AREA AND NONE OF IT
; CAN BE KEPT IN ROM. ANY CONSTANTS IN THIS AREA CANNOT
; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE 
; PROGRAM INSTRUCTIONS IN ROM.
;
; --- GENERAL RAM ---:
CHARAC: .RES 1          ;A DELIMITING CHARACTER.
INTEGR=CHARAC                   ;A ONE-BYTE INTEGER FROM "QINT".
ENDCHR: .RES 1          ;THE OTHER DELIMITING CHARACTER.
COUNT:  .RES 1          ;A GENERAL COUNTER.

; --- FLAGS ---:
DIMFLG: .RES 1          ;IN GETTING A POINTER TO A VARIABLE
                                ;IT IS IMPORTANT TO REMEMBER WHETHER IT
                                ;IS BEING DONE FOR "DIM" OR NOT.
                                ;DIMFLG AND VALTYP MUST BE
                                ;CONSECUTIVE LOCATIONS.
KIMY=DIMFLG                     ;PLACE TO PRESERVE Y DURING OUT.
VALTYP: .RES 1          ;THE TYPE INDICATOR.
                                ;0=NUMERIC 1=STRING.
INTFLG: .RES 1          ;TELLS IF INTEGER.
DORES:  .RES 1          ;WHETHER CAN OR CAN'T CRUNCH RES'D WORDS.
                                ;TURNED ON WHEN "DATA"
                                ;BEING SCANNED BY CRUNCH SO UNQUOTED
                                ;STRINGS WON'T BE CRUNCHED.
GARBFL=DORES                    ;WHETHER TO DO GARBAGE COLLECTION.
SUBFLG: .RES 1          ;FLAG WHETHER SUB'D VARIABLE ALLOWED.
                                ;"FOR" AND USER-DEFINED FUNCTION
                                ;POINTER FETCHING TURN
                                ;THIS ON BEFORE CALLING "PTRGET"
                                ;SO ARRAYS WON'T BE DETECTED.
                                ;"STKINI" AND "PTRGET" CLEAR IT.
                                ;ALSO DISALLOWS INTEGERS THERE.
INPFLG: .RES 1          ;FLAGS WHETHER WE ARE DOING "INPUT"
                                ;OR "READ".
TANSGN: .RES 1          ;USED IN DETERMINING SIGN OF TANGENT.
CNTWFL: .RES 1          ;SUPPRESS OUTPUT FLAG.
                                ;NON-ZERO MEANS SUPPRESS.
                                ;RESET BY "INPUT", READY AND ERRORS.
                                ;COMPLEMENTED BY INPUT OF ^O.

; --- RAM DEALING WITH TERMINAL HANDLING ---:
CHANNL: .RES 1          ;HOLDS CHANNEL NUMBER.
LINWID: .BYTE LINLEN                    ;LENGTH OF LINE (WIDTH).
NCMWID: .BYTE NCMPOS                    ;POSITION BEYOND WHICH THERE ARE
                                ;NO MORE FIELDS.
LINNUM: .BYTE 0                 ;LOCATION TO STORE LINE NUMBER BEFORE BUF
                                ;SO THAT "BLTUC" CAN STORE IT ALL AWAY AT ONCE.
        .BYTE 44                        ;A COMMA (PRELOAD OR FROM ROM)
                                ;USED BY INPUT STATEMENT SINCE THE
                                ;DATA POINTER ALWAYS STARTS ON A
                                ;COMMA OR TERMINATOR.
                                ;DIRECT STATEMENTS EXECUTE OUT OF
                                ;HERE. REMEMBER "INPUT" SMASHES BUF.
                                ;MUST BE ON PAGE ZERO
                                ;OR ASSIGNMENT OF STRING
                                ;VALUES IN DIRECT STATEMENTS WON'T COPY
                                ;INTO STRING SPACE -- WHICH IT MUST.
                                ;N.B. TWO NONZERO BYTES MUST PRECEDE "BUFLNM".

; --- STORAGE FOR TEMPORARY THINGS ---:
TEMPPT: .RES 1          ;POINTER AT FIRST FREE TEMP DESCRIPTOR.
                                ;INITIALIZED TO POINT TO TEMPST.
LASTPT: .RES 2          ;POINTER TO LAST-USED STRING TEMPORARY.
TEMPST: .RES STRSIZ*NUMTMP      ;STORAGE FOR NUMTMP TEMP DESCRIPTORS.
INDEX1: .RES 2          ;INDEXES.
INDEX=INDEX1
INDEX2: .RES 2
RESHO:  .RES 1          ;RESULT OF MULTIPLIER AND DIVIDER.
RESMOH: .RES 1          ;ONE MORE BYTE.
RESMO:  .RES 1
RESLO:  .RES 1
ADDEND=RESMO                    ;TEMPORARY USED BY "UMULT".
        .BYTE 0                 ;OVERFLOW FOR RES.

; --- POINTERS INTO DYNAMIC DATA STRUCTURES ---;
TXTTAB: .RES 2          ;POINTER TO BEGINNING OF TEXT.
                                ;DOESN'T CHANGE AFTER BEING
                                ;SETUP BY "INIT".
VARTAB: .RES 2          ;POINTER TO START OF SIMPLE
                                ;VARIABLE SPACE.
                                ;UPDATED WHENEVER THE SIZE OF THE
                                ;PROGRAM CHANGES, SET TO [TXTTAB]
                                ;BY "SCRATCH" ("NEW").
ARYTAB: .RES 2          ;POINTER TO BEGINNING OF ARRAY
                                ;TABLE.
                                ;INCREMENTED BY 6 WHENEVER
                                ;A NEW SIMPLE VARIABLE IS FOUND, AND
                                ;SET TO [VARTAB] BY "CLEARC".
STREND: .RES 2          ;END OF STORAGE IN USE.
                                ;INCREASED WHENEVER A NEW ARRAY
                                ;OR SIMPLE VARIABLE IS ENCOUNTERED.
                                ;SET TO [VARTAB] BY "CLEARC".
FRETOP: .RES 2          ;TOP OF STRING FREE SPACE.
FRESPC: .RES 2          ;POINTER TO NEW STRING.
MEMSIZ: .RES 2          ;HIGHEST LOCATION IN MEMORY.

; --- LINE NUMBERS AND TEXTUAL POINTERS ---:
CURLIN: .RES 2          ;CURRENT LINE #.
                                ;SET TO 0,255 FOR DIRECT STATEMENTS.
OLDLIN: .RES 2          ;OLD LINE NUMBER (SETUP BY ^C,"STOP"
                                ;OR "END" IN A PROGRAM).
POKER=LINNUM                    ;SET UP LOCATION USED BY POKE.
                                ;TEMPORARY FOR INPUT AND READ CODE
OLDTXT: .RES 2          ;OLD TEXT POINTER.
                                ;POINTS AT STATEMENT TO BE EXEC'D NEXT.
DATLIN: .RES 2          ;DATA LINE # -- REMEMBER FOR ERRORS.
DATPTR: .RES 2          ;POINTER TO DATA. INITIALIZED TO POINT
                                ;AT THE ZERO IN FRONT OF [TXTTAB]
                                ;BY "RESTORE" WHICH IS CALLED BY "CLEARC".
                                ;UPDATED BY EXECUTION OF A "READ".
INPPTR: .RES 2          ;THIS REMEMBERS WHERE INPUT IS COMING FROM.

; --- STUFF USED IN EVALUATIONS ---:
VARNAM: .RES 2          ;VARIABLE'S NAME IS STORED HERE.
VARPNT: .RES 2          ;POINTER TO VARIABLE IN MEMORY.
FDECPT=VARPNT                   ;POINTER INTO POWER OF TENS OF "FOUT".
FORPNT: .RES 2          ;A VARIABLE'S POINTER FOR "FOR" LOOPS
                                ;AND "LET" STATEMENTS.
LSTPNT=FORPNT                   ;PNTR TO LIST STRING.
ANDMSK=FORPNT                   ;THE MASK USED BY WAIT FOR ANDING.
EORMSK=FORPNT+1         ;THE MASK FOR EORING IN WAIT.
OPPTR:  .RES 2          ;POINTER TO CURRENT OP'S ENTRY IN "OPTAB".
VARTXT=OPPTR                    ;POINTER INTO LIST OF VARIABLES.
OPMASK: .RES 1          ;MASK CREATED BY CURRENT OPERATOR.
DOMASK=TANSGN                   ;MASK IN USE BY RELATION OPERATIONS.
DEFPNT: .RES 2          ;POINTER USED IN FUNCTION DEFINITION.
GRBPNT=DEFPNT                   ;ANOTHER USED IN GARBAGE COLLECTION.
DSCPNT: .RES 2          ;POINTER TO A STRING DESCRIPTOR.
.RES 1  ;FOR TEMPF3.
FOUR6:  .BYTE STRSIZ            ;VARIABLE CONSTANT USED BY GARB COLLECT.

; --- ET CETERA ---:
JMPER:  JMP     60000
SIZE=JMPER+1
OLDOV=JMPER+2                   ;THE OLD OVERFLOW.
TEMPF3= DEFPNT                  ;A THIRD FAC TEMPORARY (4 BYTES).
TEMPF1:
.BYTE 0         ;FOR TEMPF1S EXTRA BYTE.
HIGHDS: .RES 2          ;DESINATION OF HIGHEST ELEMENT IN BLT.
HIGHTR: .RES 2          ;SOURCE OF HIGHEST ELEMENT TO MOVE.
TEMPF2:
.BYTE 0         ;FOR TEMPF2S EXTRA BYTE.
LOWDS:  .RES 2          ;LOCATION OF LAST BYTE TRANSFERRED INTO.
LOWTR:  .RES 2          ;LAST THING TO MOVE IN BLT.
ARYPNT=HIGHDS                   ;A POINTER USED IN ARRAY BUILDING.
GRBTOP=LOWTR                    ;A POINTER USED IN GARBAGE COLLECTION.
DECCNT=LOWDS                    ;NUMBER OF PLACES BEFORE DECIMAL POINT.
TENEXP=LOWDS+1                  ;HAS A DPT BEEN INPUT?
DPTFLG=LOWTR                    ;BASE TEN EXPONENT.
EXPSGN=LOWTR+1                  ;SIGN OF BASE TEN EXPONENT.

; --- THE FLOATING ACCUMULATOR ---:
FAC:
FACEXP: .BYTE 0
FACHO:  .BYTE 0                 ;MOST SIGNIFICANT BYTE OF MANTISSA.
FACMOH: .BYTE 0                 ;ONE MORE.
FACMO:  .BYTE 0                 ;MIDDLE ORDER OF MANTISSA.
FACLO:  .BYTE 0                 ;LEAST SIG BYTE OF MANTISSA.
FACSGN: .BYTE 0                 ;SIGN OF FAC (0 OR -1) WHEN UNPACKED.
SGNFLG: .BYTE 0                 ;SIGN OF FAC IS PRESERVED BERE BY "FIN".
DEGREE=SGNFLG                   ;A COUNT USED BY POLYNOMIALS.
DSCTMP=FAC                      ;THIS IS WHERE TEMP DESCS ARE BUILT.
INDICE=FACMO                    ;INDICE IS SET UP HERE BY "QINT".
BITS:   .BYTE 0                 ;SOMETHING FOR "SHIFTR" TO USE.

; --- THE FLOATING ARGUMENT (UNPACKED) ---:
ARGEXP: .BYTE 0
ARGHO:  .BYTE 0
ARGMOH: .BYTE 0
ARGMO:  .BYTE 0
ARGLO:  .BYTE 0
ARGSGN: .BYTE 0

ARISGN: .BYTE 0                 ;A SIGN REFLECTING THE RESULT.
FACOV:  .BYTE 0                 ;OVERFLOW BYTE OF THE FAC.
STRNG1= ARISGN                  ;POINTER TO A STRING OR DESCRIPTOR.

FBUFPT: .RES 2          ;POINTER INTO FBUFFR USED BY FOUT.
BUFPTR=FBUFPT                   ;POINTER TO BUF USED BY "CRUNCH".
STRNG2= FBUFPT                  ;POINTER TO STRING OR DESC.
POLYPT=FBUFPT                   ;POINTER INTO POLYNOMIAL COEFFICIENTS.
CURTOL=FBUFPT                   ;ABSOLUTE LINEAR INDEX IS FORMED HERE.
; SUBTTL        RAM CODE.
; THIS CODE GETS CHANGED THROUGHOUT EXECUTION.
; IT IS MADE TO BE FAST THIS WAY.
; ALSO, [X] AND [Y] ARE NOT DISTURBED
;
; "CHRGET" USING [TXTPTR] AS THE CURRENT TEXT PNTR
; FETCHES A NEW CHARACTER INTO ACCA AFTER INCREMENTING [TXTPTR]
; AND SETS CONDITION CODES ACCORDING TO WHAT'S IN ACCA.
;       NOT C=  NUMERIC   ("0" THRU "9")
;       Z=      ":" OR END-OF-LINE (A NULL)
;
; [ACCA] = NEW CHAR.
; [TXTPTR]=[TXTPTR]+1
;
; THE FOLLOWING EXISTS IN ROM IF ROM EXISTS AND IS LOADED
; DOWN HERE BY INIT. OTHERWISE IT IS JUST LOADED INTO THIS
; RAM LIKE ALL THE REST OF RAM IS LOADED.
;
CHRGET: INC     CHRGET+7        ;INCREMENT THE WHOLE TXTPTR.
        BNE     CHRGOT
        INC     CHRGET+8
CHRGOT: LDA     60000           ;A LOAD WITH AN EXT ADDR.
TXTPTR=CHRGOT+1
        CMP     #' '            ;SKIP SPACES.
        BEQ     CHRGET
QNUM:   CMP     #':'            ;IS IT A ":"?
        BCS     CHRRTS          ;IT IS .GE. ":"
        SEC
        SBC     #'0'            ;ALL CHARS .GT. "9" HAVE RET'D SO
        SEC
        SBC     #256-'0'                ;SEE IF NUMERIC.
                                ;TURN CARRY ON IF NUMERIC.
                                ;ALSO, SETZ IF NULL.
CHRRTS: RTS                     ;RETURN TO CALLER.

RNDX:   .BYTE 128                       ;LOADED OR FROM ROM.
        .BYTE 79                        ;THE INITIAL RANDOM NUMBER.
        .BYTE 199
        .BYTE 82
.BYTE 89                ;ONE MORE BYTE.

LOFBUF=$00ff
FBUFFR=$0100

;STACK IS LOCATED HERE. IE FROM THE END OF FBUFFR TO STKEND.
; SUBTTL        DISPATCH TABLES, RESERVED WORDS, AND ERROR TEXTS.

.SEGMENT "CODE": absolute

STMDSP: .WORD END-1
        .WORD FOR-1
        .WORD NEXT-1
        .WORD DATA-1
        .WORD INPUTN-1
        .WORD INPUT-1
        .WORD DIM-1
        .WORD READ-1
        .WORD LET-1
        .WORD GOTO-1
        .WORD RUN-1
        .WORD IF-1
        .WORD RESTOR-1
        .WORD GOSUB-1
        .WORD RETURN-1
        .WORD REM-1
        .WORD STOP-1
        .WORD ONGOTO-1
        .WORD FNWAIT-1
        .WORD CQLOAD-1
        .WORD CQSAVE-1
        .WORD CQVERF-1
        .WORD DEF-1
        .WORD POKE-1
        .WORD PRINTN-1
        .WORD PRINT-1
        .WORD CONT-1
        .WORD LIST-1
        .WORD CLEAR-1
        .WORD CMD-1
        .WORD CQSYS-1
        .WORD CQOPEN-1
        .WORD CQCLOS-1
        .WORD GET-1             ;FILL W/ GET ADDR.
        .WORD SCRATH-1

FUNDSP: .WORD SGN
        .WORD INT
        .WORD ABS
USRLOC: .WORD USRPOK
        .WORD FRE
        .WORD POS
        .WORD SQR
        .WORD RND
        .WORD LOG
        .WORD EXP
COSFIX: .WORD COS
SINFIX: .WORD SIN
TANFIX: .WORD TAN
ATNFIX: .WORD ATN
        .WORD PEEK
        .WORD LEN
        .WORD STR
        .WORD VAL
        .WORD ASC
        .WORD CHR
        .WORD LEFT
        .WORD RIGHT
        .WORD MID
OPTAB:  .BYTE 121
        .WORD FADDT-1
        .BYTE 121
        .WORD FSUBT-1
        .BYTE 123
        .WORD FMULTT-1
        .BYTE 123
        .WORD FDIVT-1
        .BYTE 127
        .WORD FPWRT-1
        .BYTE 80
        .WORD ANDOP-1
        .BYTE 70
        .WORD OROP-1
NEGTAB: .BYTE 125
        .WORD NEGOP-1
NOTTAB: .BYTE 90
        .WORD NOTOP-1
PTDORL: .BYTE 100                       ;PRECEDENCE.
        .WORD DOREL-1   ;OPERATOR ADDRESS.
;
; TOKENS FOR RESERVED WORDS ALWAYS HAVE THE MOST
; SIGNIFICANT BIT ON.
; THE LIST OF RESERVED WORDS:
;
Q .SET 128-1
.MACRO DCI STR
  .REPEAT .STRLEN(STR)-1,I
    .BYTE .STRAT(STR,I)
  .ENDREP
  .BYTE .STRAT(STR,.STRLEN(STR)-1) | $80
  Q .SET Q+1
.ENDMACRO

RESLST: DCI"END"
ENDTK=Q
        DCI"FOR"
FORTK=Q
        DCI"NEXT"
        DCI"DATA"
DATATK=Q
        DCI"INPUT#"
        DCI"INPUT"
        DCI"DIM"
        DCI"READ"
        DCI"LET"
        DCI"GOTO"
GOTOTK=Q
        DCI"RUN"
        DCI"IF"
        DCI"RESTORE"
        DCI"GOSUB"
GOSUTK=Q
        DCI"RETURN"
        DCI"REM"
REMTK=Q
        DCI"STOP"
        DCI"ON"
        DCI"WAIT"
        DCI"LOAD"
        DCI"SAVE"
        DCI"VERIFY"
        DCI"DEF"
        DCI"POKE"
        DCI"PRINT#"
        DCI"PRINT"
PRINTK=Q
        DCI"CONT"
        DCI"LIST"
        DCI"CLR"
        DCI"CMD"
        DCI"SYS"
        DCI"OPEN"
        DCI"CLOSE"
        DCI"GET"
        DCI"NEW"
SCRATK=Q
; END OF COMMAND LIST.
        DCI"TAB("
TABTK=Q
        DCI"TO"
TOTK=Q
        DCI"FN"
FNTK=Q
        DCI"SPC("
SPCTK=Q
        DCI"THEN"
THENTK=Q
        DCI"NOT"
NOTTK=Q
        DCI"STEP"
STEPTK=Q
        DCI"+"
PLUSTK=Q
        DCI"-"
MINUTK=Q
        DCI"*"
        DCI"/"
        DCI"^"
        DCI"AND"
        DCI"OR"
        .BYTE 190                       ;A GREATER THAN SIGN
Q .SET Q+1
GREATK=Q
        DCI"="
EQULTK=Q
        .BYTE 188
Q .SET Q+1                      ;A LESS THAN SIGN
LESSTK=Q
;
; NOTE DANGER OF ONE RESERVED WORD BEING A PART
; OF ANOTHER:
; IE . . IF 2 GREATER THAN F OR T=5 THEN...
; WILL NOT WORK!!! SINCE "FOR" WILL BE CRUNCHED!!
; IN ANY CASE MAKE SURE THE SMALLER WORD APPEARS
; SECOND IN THE RESERVED WORD TABLE ("INP" AND "INPUT")
; ANOTHER EXAMPLE: IF T OR Q THEN ... "TO" IS CRUNCHED
;
        DCI"SGN"
ONEFUN=Q
        DCI"INT"
        DCI"ABS"
        DCI"USR"
        DCI"FRE"
        DCI"POS"
        DCI"SQR"
        DCI"RND"
        DCI"LOG"
        DCI"EXP"
        DCI"COS"
        DCI"SIN"
        DCI"TAN"
        DCI"ATN"
        DCI"PEEK"
        DCI"LEN"
        DCI"STR$"
        DCI"VAL"
        DCI"ASC"
        DCI"CHR$"
LASNUM=Q                        ;NUMBER OF LAST FUNCTION
                                ;THAT TAKES ONE ARG
        DCI"LEFT$"
        DCI"RIGHT$"
        DCI"MID$"
        DCI"GO"
GOTK=Q
        .BYTE 0                 ;MARKS END OF RESERVED WORD LIST


Q .SET 0
; NOTE: THIS ERROR COUNT TECHNIQUE WILL NOT WORK IF THERE ARE MORE
; THAN 256 CHARACTERS OF ERROR MESSAGES
ERRTAB: DC"NEXT WITHOUT FOR"
ERRNF=Q
Q .SET Q+16
        DC"SYNTAX"
ERRSN=Q
Q .SET Q+6
        DC"RETURN WITHOUT GOSUB"
ERRRG=Q
Q .SET Q+20
        DC"OUT OF DATA"
ERROD=Q
Q .SET Q+11
        DC"ILLEGAL QUANTITY"
ERRFC=Q
Q .SET Q+16
        DC"OVERFLOW"
ERROV=Q
Q .SET Q+8
        DC"OUT OF MEMORY"
ERROM=Q
Q .SET Q+13
        DC"UNDEF'D STATEMENT"
ERRUS=Q
Q .SET Q+17
        DC"BAD SUBSCRIPT"
ERRBS=Q
Q .SET Q+13
        DC"REDIM'D ARRAY"
ERRDD=Q
Q .SET Q+13
        DC"DIVISION BY ZERO"
ERRDV0=Q
Q .SET Q+16
        DC"ILLEGAL DIRECT"
ERRID=Q
Q .SET Q+14
        DC"TYPE MISMATCH"
ERRTM=Q
Q .SET Q+13
        DC"STRING TOO LONG"
ERRLS=Q
Q .SET Q+15
        DC"FILE DATA"
ERRBD=Q
Q .SET Q+9
        DC"FORMULA TOO COMPLEX"
ERRST=Q
Q .SET Q+19
        DC"CAN'T CONTINUE"
ERRCN=Q
Q .SET Q+14
        DC"UNDEF'D FUNCTION"
ERRUF=Q

;
; NEEDED FOR MESSAGES IN ALL VERSIONS.
;
ERR:    DT" ERROR"
        .BYTE 0
INTXT:  DT" IN "
        .BYTE 0
REDDY:  ACRLF
        DT"READY."
        ACRLF
        .BYTE 0
BRKTXT: ACRLF
        DT"BREAK"
        .BYTE 0
; SUBTTL        GENERAL STORAGE MANAGEMENT ROUTINES.
;
; FIND A "FOR" ENTRY ON THE STACK VIA "VARPNT".
;
FORSIZ=2*ADDPRC+16
FNDFOR: TSX                     ;LOAD XREG WITH STK PNTR.
        INX
        INX
        INX
        INX
FFLOOP: LDA     257,X           ;GET STACK ENTRY.
        CMP     #FORTK          ;IS IT A "FOR" TOKEN?
        BNE     FFRTS           ;NO, NO "FOR" LOOPS WITH THIS PNTR.
        LDA     FORPNT+1        ;GET HIGH.
        BNE     CMPFOR
        LDA     258,X           ;PNTR IS ZERO, SO ASSUME THIS ONE.
        STA     FORPNT
        LDA     259,X
        STA     FORPNT+1
CMPFOR: CMP     259,X
        BNE     ADDFRS          ;NOT THIS ONE.
        LDA     FORPNT          ;GET DOWN.
        CMP     258,X
        BEQ     FFRTS           ;WE GOT IT! WE GOT IT!
ADDFRS: TXA
        CLC                     ;ADD 16 TO X.
        ADC     #FORSIZ
        TAX                     ;RESULT BACK INTO X.
        BNE     FFLOOP
FFRTS:  RTS                     ;RETURN TO CALLER.

;
; THIS IS THE BLOCK TRANSFER ROUTINE.
; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD.
;
; ON ENTRY:
; [Y,A]=[HIGHDS]    (FOR REASON).
; [HIGHDS]= DESTINATION OF [HIGH ADDRESS].
; [LOWTR]= LOWEST ADDR TO BE TRANSFERRED.
; [HIGHTR]= HIGHEST ADDR TO BE TRANSFERRED.
;
; A CHECK IS MADE TO ASCERTAIN THAT A REASONABLE
; AMOUNT OF SPACE REMAINS BETWEEN THE BOTTOM
; OF THE STRINGS AND THE HIGHEST LOCATION TRANSFERRED INTO.
;
; ON EXIT:
; [LOWTR] ARE UNCHANGED.
; [HIGHTR]=[LOWTR]-200 OCTAL.
; [HIGHDS]=LOWEST ADDR TRANSFERRED INTO MINUS 200 OCTAL.
;
BLTU:   JSR     REASON          ;ASCERTAIN THAT STRING SPACE WON'T
                                ;BE OVERRUN.
        STWD    STREND
BLTUC:  SEC                     ;PREPARE TO SUBTRACT.
        LDA     HIGHTR
        SBC     LOWTR           ;COMPUTE NUMBER OF THINGS TO MOVE.
        STA     INDEX           ;SAVE FOR LATER.
        TAY
        LDA     HIGHTR+1
        SBC     LOWTR+1
        TAX                     ;PUT IT IN A COUNTER REGISTER.
        INX                     ;SO THAT COUNTER ALGORITHM WORKS.
        TYA                     ;SEE IF LOW PART OF COUNT IS ZERO.
        BEQ     DECBLT          ;YES, GO START MOVING BLOCKS.
        LDA     HIGHTR          ;NO, MUST MODIFY BASE ADDR.
        SEC
        SBC     INDEX           ;BORROW IS OFF SINCE [HIGHTR].GT.[LOWTR].
        STA     HIGHTR          ;SAVE MODIFIED BASE ADDR.
        BCS     BLT1            ;IF NO BORROW, GO SHOVE IT.
        DEC     HIGHTR+1        ;BORROW IMPLIES SUB 1 FROM HIGH ORDER.
        SEC
BLT1:   LDA     HIGHDS          ;MOD BASE OF DEST ADDR.
        SBC     INDEX
        STA     HIGHDS
        BCS     MOREN1          ;NO BORROW.
        DEC     HIGHDS+1        ;DECREMENT HIGH ORDER BYTE.
        BCC     MOREN1          ;ALWAYS SKIP.
BLTLP:  LDA     (HIGHTR),Y              ;FETCH BYTE TO MOVE
        STA     (HIGHDS),Y              ;MOVE IT IN, MOVE IT OUT.
MOREN1: DEY
        BNE     BLTLP
        LDA     (HIGHTR),Y              ;MOVE LAST OF THE BLOCK.
        STA     (HIGHDS),Y
DECBLT: DEC     HIGHTR+1
        DEC     HIGHDS+1        ;START ON NEW BLOCKS.
        DEX
        BNE     MOREN1
        RTS                     ;RETURN TO CALLER.

;
; THIS ROUTINE IS USED TO ASCERTAIN THAT A GIVEN
; NUMBER OF LOCS REMAIN AVAILABLE FOR THE STACK.
;    THE CALL IS:
;       LDAI    NUMBER OF 2-BYTE ENTRIES NEEDED.
;       JSR     GETSTK
;
; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
; AN ARBITRARY AMOUNT OF STUFF ON THE STACK,
; I.E., ANY RECURSIVE ROUTINE LIKE "FRMEVL".
; IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
; WHICH MAKE PERMANENT ENTRIES ON THE STACK.
;
; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
; NUMLEV LOCATIONS NEED NOT CALL THIS.
;
;
; ON EXIT:
;    [A] AND [X] HAVE BEEN MODIFIED.
;
GETSTK: ASL     A               ;MULT [A] BY 2. NB, CLEARS C BIT.
        ADC     #2*NUMLEV+(3*ADDPRC)+13 ;MAKE SURE 2*NUMLEV+13 LOCS
                                ;(13 BECAUSE OF FBUFFR)
        BCS     OMERR           ;WILL REMAIN IN STACK.
        STA     INDEX
        TSX                     ;GET STACKED.
        CPX     INDEX           ;COMPARE.
        BCC     OMERR           ;IF STACK.LE.INDEX1, OM.
        RTS

;
; [Y,A] IS A CERTAIN ADDRESS. "REASON" MAKES SURE
; IT IS LESS THAN [FRETOP].
;
REASON: CPY     FRETOP+1
        BCC     REARTS
        BNE     TRYMOR          ;GO GARB COLLECT.
        CMP     FRETOP
        BCC     REARTS
TRYMOR: PHA
        LDX     #8+ADDPRC       ;IF TEMPF2 HAS ZERO IN BETWEEN.
        TYA
REASAV: PHA
        LDA     HIGHDS-1,X      ;SAVE HIGHDS ON STACK.
        DEX
        BPL     REASAV          ;PUT 8 OF THEM ON STK.
        JSR     GARBA2          ;GO GARB COLLECT.
        LDX     #256-8-ADDPRC
REASTO: PLA
        STA     HIGHDS+8+ADDPRC,X       ;RESTORE AFTER GARB COLLECT.
        INX
        BMI     REASTO
        PLA
        TAY
        PLA                     ;RESTORE A AND Y.
        CPY     FRETOP+1        ;COMPARE HIGHS
        BCC     REARTS
        BNE     OMERR           ;HIGHER IS BAD.
        CMP     FRETOP          ;AND THE LOWS.
        BCS     OMERR
REARTS: RTS

; SUBTTL        ERROR HANDLER, READY, TERMINAL INPUT, COMPACTIFY, NEW, REINIT.
OMERR:  LDX     #ERROM
ERROR:
        LSR     CNTWFL          ;FORCE OUTPUT.
        LDA     CHANNL          ;CLOSE NON-TERMINAL CHANNEL.
        BEQ     ERRCRD
        JSR     CQCCHN          ;CLOSE IT.
        LDA     #0
        STA     CHANNL
ERRCRD: JSR     CRDO            ;OUTPUT CRLF.
        JSR     OUTQST          ;PRINT A QUESTION MARK
GETERR: LDA     ERRTAB,X
        PHA
        AND     #127            ;GET RID OF HIGH BIT.
        JSR     OUTDO           ;OUTPUT IT.
        INX
        PLA                     ;LAST CHAR OF MESSAGE?
        BPL     GETERR          ;NO. GO GET NEXT AND OUTPUT IT.
TYPERR: JSR     STKINI          ;RESET THE STACK AND FLAGS.
        LDWDI   ERR             ;GET PNTR TO " ERROR".
ERRFIN: JSR     STROUT          ;OUTPUT IT.
        LDY     CURLIN+1
        INY                     ;WAS NUMBER 64000?
        BEQ     READY           ;YES, DON'T TYPE LINE NUMBER.
        JSR     INPRT
READY:
        LSR     CNTWFL          ;TURN OUTPUT BACK ON IF SUPRESSED
        LDWDI   REDDY           ;SAY "OK".
        JSR     STROUT          ;NO INIT ERRORS POSSIBLE.
MAIN:   JSR     INLIN           ;GET A LINE FROM TERMINAL.
        STXY    TXTPTR
        JSR     CHRGET
        TAX                     ;SET ZERO FLAG BASED ON [A]
                                ;THIS DISTINGUISHES ":" AND 0
        BEQ     MAIN            ;IF BLANK LINE, GET ANOTHER.
        LDX     #255            ;SET DIRECT LINE NUMBER.
        STX     CURLIN+1
        BCC     MAIN1           ;IS A LINE NUMBER. NOT DIRECT.
        JSR     CRUNCH          ;COMPACTIFY.
        JMP     GONE            ;EXECUTE IT.
MAIN1:  JSR     LINGET          ;READ LINE NUMBER INTO "LINNUM".
        JSR     CRUNCH
        STY     COUNT           ;RETAIN CHARACTER COUNT.
        JSR     FNDLIN
        BCC     NODEL           ;NO MATCH, SO DON'T DELETE.
        LDY     #1
        LDA     (LOWTR),Y
        STA     INDEX1+1
        LDA     VARTAB
        STA     INDEX1
        LDA     LOWTR+1         ;SET TRANSFER TO.
        STA     INDEX2+1
        LDA     LOWTR
        DEY
        SBC     (LOWTR),Y               ;COMPUTE NEGATIVE LENGTH.
        CLC
        ADC     VARTAB          ;COMPUTE NEW VARTAB.
        STA     VARTAB
        STA     INDEX2          ;SET LOW OF TRANS TO.
        LDA     VARTAB+1
        ADC     #255
        STA     VARTAB+1        ;COMPUTE HIGH OF VARTAB.
        SBC     LOWTR+1         ;COMPUTE NUMBER OF BLOCKS TO MOVE.
        TAX
        SEC
        LDA     LOWTR
        SBC     VARTAB          ;COMPUTE OFFSET.
        TAY
        BCS     QDECT1          ;IF VARTAB.LE.LOWTR,
        INX                     ;DECR DUE TO CARRY, AND
        DEC     INDEX2+1        ;DECREMENT STORE SO CARRY WORKS.
QDECT1: CLC
        ADC     INDEX1
        BCC     MLOOP
        DEC     INDEX1+1
        CLC                     ;FOR LATER ADCQ
MLOOP:  LDA     (INDEX1),Y
        STA     (INDEX2),Y
        INY
        BNE     MLOOP           ;BLOCK DONE?
        INC     INDEX1+1
        INC     INDEX2+1
        DEX
        BNE     MLOOP           ;DO ANOTHER BLOCK. ALWAYS.
NODEL:  JSR     RUNC            ;RESET ALL VARIABLE INFO SO GARBAGE
                                ;COLLECTION CAUSED BY REASON WILL WORK
        JSR     LNKPRG          ;FIX UP THE LINKS
        LDA     BUF             ;SEE IF ANYTHNG THERE
        BEQ     MAIN
        CLC
        LDA     VARTAB
        STA     HIGHTR          ;SETUP HIGHTR.
        ADC     COUNT           ;ADD LENGTH OF LINE TO INSERT.
        STA     HIGHDS          ;THIS GIVES DEST ADDR.
        LDY     VARTAB+1
        STY     HIGHTR+1        ;SAME FOR HIGH ORDERS.
        BCC     NODELC
        INY
NODELC: STY     HIGHDS+1
        JSR     BLTU
        LDWD    LINNUM          ;POSITION THE BINARY LINE NUMBER
        STWD    BUF-2           ;IN FRONT OF BUF
        LDWD    STREND
        STWD    VARTAB
        LDY     COUNT
        DEY
STOLOP: LDA     BUF-4,Y
        STA     (LOWTR),Y
        DEY
        BPL     STOLOP
FINI:   JSR     RUNC            ;DO CLEAR & SET UP STACK.
                                ;AND SET [TXTPTR] TO [TXTTAB]-1.
        JSR     LNKPRG          ;FIX UP PROGRAM LINKS
        JMP     MAIN
LNKPRG: LDWD    TXTTAB          ;SET [INDEX] TO [TXTTAB].
        STWD    INDEX
        CLC
;
; CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
; UP ALL THE LINKS. THE END OF EACH LINE IS FOUND
; BY SEARCHING FOR THE ZERO AT THE END.
; THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM.
;
CHEAD:  LDY     #1
        LDA     (INDEX),Y               ;ARRIVED AT DOUBLE ZEROES?
        BEQ     LNKRTS
        LDY     #4
CZLOOP: INY                     ;THERE IS AT LEAST ONE BYTE.
        LDA     (INDEX),Y
        BNE     CZLOOP          ;NO, CONTINUE SEARCHING.
        INY                     ;GO ONE BEYOND.
        TYA
        ADC     INDEX
        TAX
        LDY     #0
        STA     (INDEX),Y
        LDA     INDEX+1
        ADC     #0
        INY
        STA     (INDEX),Y
        STX     INDEX
        STA     INDEX+1
        BCCA    CHEAD           ;ALWAYS BRANCHES.
LNKRTS: RTS
;
; THIS IS THE LINE INPUT ROUTINE.
; IT READS CHARACTERS INTO BUF USING BACKARROW (UNDERSCORE, OR
; SHIFT O) AS THE DELETE CHARACTER AND @ AS THE 
; LINE DELETE CHARACTER. IF MORE THAN BUFLEN CHARACTERS
; ARE TYPED, NO ECHOING IS DONE UNTIL A BACKARROW OR @ OR CR
; IS TYPED. CONTROL-G WILL BE TYPED FOR EACH EXTRA CHARACTER.
; THE ROUTINE IS ENTERED AT INLIN.
;
INLIN:  LDX     #0
INLINC: JSR     INCHR           ;GET A CHARACTER.
        CMP     #13             ;CARRIAGE RETURN?
        BEQ     FININ1          ;YES, FINISH UP.
GOODCH:
        STA     BUF,X
        INX
BNE INLINC
FININ1: JMP     FININL          ;GO TO FININL FAR, FAR AWAY.
INCHR:  
        JSR     CQINCH          ;FOR COMMODORE.

        LDY     CHANNL          ;CNT-O HAS NO EFFECT IF NOT FROM TERM.
        BNE     INCRTS
        CMP     #CONTW          ;SUPPRESS OUTPUT CHARACTER (^W).
        BNE     INCRTS          ;NO, RETURN.
        PHA
        COM     CNTWFL          ;COMPLEMENT ITS STATE.
        PLA
INCRTS: RTS                     ;END OF INCHR.
        
;
; ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
; BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME 
; BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
; THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
; RESERVED WORD LIST IN THE SAME ORDER THEY
; APPEAR IN STMDSP.
;
                                ;BUFOFS IS THE AMOUNT TO OFFSET THE LOW BYTE
                                ;OF THE TEXT POINTER TO GET TO BUF**
                                ;AFTER TXTPTR HAS BEEN SETUP TO POINT INTO BUF
BUFOFS=(BUF/256)*256
CRUNCH: LDX     TXTPTR          ;SET SOURCE POINTER.
        LDY     #4              ;SET DESTINATION OFFSET.
        STY     DORES           ;ALLOW CRUNCHING.
KLOOP:  LDA     BUFOFS,X
        BPL     CMPSPC          ;GO LOOK AT SPACES.
        CMP     #PI             ;PI??
        BEQ     STUFFH          ;GO SAVE IT.
        INX                     ;SKIP NO PRINTING.
        BNE     KLOOP           ;ALWAYS GOES.
CMPSPC: CMP     #' '            ;IS IT A SPACE TO SAVE?
        BEQ     STUFFH          ;YES, GO SAVE IT.
        STA     ENDCHR          ;IF IT'S A QUOTE, THIS WILL
                                ;STOP LOOP WHEN OTHER QUOTE APPEARS.
        CMP     #34             ;QUOTE SIGN?
        BEQ     STRNG           ;YES, DO SPECIAL STRING HANDLING.
        BIT     DORES           ;TEST FLAG.
        BVS     STUFFH          ;NO CRUNCH, JUST STORE.
        CMP     #'?'            ;A QMARK?
        BNE     KLOOP1
        LDA     #PRINTK         ;YES, STUFF A "PRINT" TOKEN.
        BNE     STUFFH          ;ALWAYS GO TO STUFFH.
KLOOP1: CMP     #'0'            ;SKIP NUMERICS.
        BCC     MUSTCR
        CMP     #60             ;":" AND ";" ARE ENTERED STRAIGHTAWAY.
        BCC     STUFFH
MUSTCR: STY     BUFPTR          ;SAVE BUFFER POINTER.
        LDY     #0              ;LOAD RESLST POINTER.
        STY     COUNT           ;ALSO CLEAR COUNT.
        DEY
        STX     TXTPTR          ;SAVE TEXT POINTER FOR LATER USE.
        DEX
RESER:  INY
RESPUL: INX
RESCON: LDA     BUFOFS,X
        SEC                     ;PREPARE TO SUBSTARCT.
        SBC     RESLST,Y        ;CHARACTERS EQUAL?
        BEQ     RESER           ;YES, CONTINUE SEARCH.
        CMP     #128            ;NO BUT MAYBE THE END IS HERE.
        BNE     NTHIS           ;NO, TRULY UNEQUAL.
        ORA     COUNT
GETBPT: LDY     BUFPTR          ;GET BUFFER PNTR.
STUFFH: INX
        INY
        STA     BUF-5,Y
        LDA     BUF-5,Y
        BEQ     CRDONE          ;NULL IMPLIES END OF LINE.
        SEC                     ;PREPARE TO SUBSTARCT.
        SBC     #':'            ;IS IT A ":"?
        BEQ     COLIS           ;YES, ALLOW CRUNCHING AGAIN.
        CMP     #DATATK-':'     ;IS IT A DATATK?
        BNE     NODATT          ;NO, SEE IF IT IS REM TOKEN.
COLIS:  STA     DORES           ;SETUP FLAG.
NODATT: SEC                     ;PREP TO SBCQ
        SBC     #REMTK-':'      ;REM ONLY STOPS ON NULL.
        BNE     KLOOP           ;NO, CONTINUE CRUNCHING.
        STA     ENDCHR          ;REM STOPS ONLY ON NULL, NOT : OR ".
STR1:   LDA     BUFOFS,X
        BEQ     STUFFH          ;YES, END OF LINE, SO DONE.
        CMP     ENDCHR          ;END OF GOBBLE?
        BEQ     STUFFH          ;YES, DONE WITH STRING.
STRNG:  INY                     ;INCREMENT BUFFER POINTER.
        STA     BUF-5,Y
        INX
        BNE     STR1            ;PROCESS NEXT CHARACTER.
NTHIS:  LDX     TXTPTR          ;RESTORE TEXT POINTER.
        INC     COUNT           ;INCREMENT RES WORD COUNT.
NTHIS1: INY
        LDA     RESLST-1,Y      ;GET RES CHARACTER.
        BPL     NTHIS1          ;END OF ENTRY?
        LDA     RESLST,Y        ;YES. IS IT THE END?
        BNE     RESCON          ;NO, TRY THE NEXT WORD.
        LDA     BUFOFS,X        ;YES, END OF TABLE. GET 1ST CHR.
        BPL     GETBPT          ;STORE IT AWAY (ALWAYS BRANCHES).
CRDONE: STA     BUF-3,Y ;SO THAT IF THIS IS A DIR STATEMENT
                                ;ITS END WILL LOOK LIKE END OF PROGRAM.
        DEC     TXTPTR+1
        LDA     #(BUF&255)-1    ;MAKE TXTPTR POINT TO
        STA     TXTPTR          ;CRUNCHED LINE.
LISTRT: RTS                     ;RETURN TO CALLER.
;
; FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
; WHOSE NUMBER IS PASSED IN "LINNUM".
; THERE ARE TWO POSSIBLE RETURNS:
;
;       1) CARRY SET.
;          LOWTR POINTS TO THE LINK FIELD IN THE LINE
;          WHICH IS THE ONE SEARCHED FOR.
;
;       2) CARRY NOT SET.
;          LINE NOT FOUND. [LOWTR] POINTS TO THE LINE IN THE
;          PROGRAM GREATER THAN THE ONE SOUGHT AFTER.
;
FNDLIN: LDWX    TXTTAB          ;LOAD [X,A] WITH [TXTTAB]
FNDLNC: LDY     #1
        STWX    LOWTR           ;STORE [X,A] INTO LOWTR
        LDA     (LOWTR),Y               ;SEE IF LINK IS 0
        BEQ     FLINRT
        INY
        INY
        LDA     LINNUM+1        ;COMP HIGH ORDERS OF LINE NUMBERS.
        CMP     (LOWTR),Y
        BCC     FLNRTS          ;NO SUCH LINE NUMBER.
        BEQ     FNDLO1
        DEY
        BNE     AFFRTS          ;ALWAYS BRANCH.
FNDLO1: LDA     LINNUM
        DEY
        CMP     (LOWTR),Y               ;COMPARE LOW ORDERS.
        BCC     FLNRTS          ;NO SUCH NUMBER.
        BEQ     FLNRTS          ;GO TIT.
AFFRTS: DEY
        LDA     (LOWTR),Y               ;FETCH LINK.
        TAX
        DEY
        LDA     (LOWTR),Y
        BCS     FNDLNC          ;ALWAYS BRANCHES.
FLINRT: CLC                     ;C MAY BE HIGH.
FLNRTS: RTS                     ;RETURN TO CALLER.
;
; THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL
; AS VARIABLE SPACE.
;
SCRATH: BNE     FLNRTS          ;MAKE SURE THERE IS A TERMINATOR.
SCRTCH: LDA     #0              ;GET A CLEARER.
        TAY                     ;SET UP INDEX.
        STA     (TXTTAB),Y              ;CLEAR  FIRST LINK.
        INY
        STA     (TXTTAB),Y
        LDA     TXTTAB
        CLC
        ADC     #2
        STA     VARTAB          ;SETUP [VARTAB].
        LDA     TXTTAB+1
        ADC     #0
        STA     VARTAB+1
RUNC:   JSR     STXTPT
        LDA     #0              ;SET ZERO FLAG
;
; THIS CODE IS FOR THE CLEAR COMMAND.
;
CLEAR:  BNE     STKRTS          ;SYNTAX ERROR IF NO TERMINATOR.
;
; CLEAR INITIALIZES THE VARIABLE AND
; ARRAY SPACE BY RESETING ARYTAB (THE END OF SIMPLE VARIABLE SPACE)
; AND STREND (THE END OF ARRAY STORAGE). IT FALLS INTO "STKINI"
; WHICH RESETS THE STACK. 
;
CLEARC: LDWD    MEMSIZ          ;FREE UP STRING SPACE.
        STWD    FRETOP
        JSR     CQCALL          ;CLOSE ALL OPEN FILES.
        LDWD    VARTAB          ;LIBERATE THE
        STWD    ARYTAB          ;VARIABLES AND
        STWD    STREND          ;ARRAYS.
FLOAD:  JSR     RESTOR          ;RESTORE DATA.
;
; STKINI RESETS THE STACK POINTER ELIMINATING
; GOSUB AND FOR CONTEXT. STRING TEMPORARIES ARE FREED
; UP, SUBFLG IS RESET. CONTINUING IS PROHIBITED.
; AND A DUMMY ENTRY IS LEFT AT THE BOTTOM OF THE STACK SO "FNDFOR" WILL ALWAYS
; FIND A NON-"FOR" ENTRY AT THE BOTTOM OF THE STACK.
;
STKINI: LDX     #TEMPST         ;INITIALIZE STRING TEMPORARIES.
        STX     TEMPPT
        PLA                     ;SETUP RETURN ADDRESS.
        TAY
        PLA
        LDX     #STKEND-257
        TXS
        PHA
        TYA
        PHA
        LDA     #0
        STA     OLDTXT+1        ;DISALLOWING CONTINUING
        STA     SUBFLG          ;ALLOW SUBSCRIPTS.
STKRTS: RTS

STXTPT: CLC
        LDA     TXTTAB
        ADC     #255
        STA     TXTPTR
        LDA     TXTTAB+1
        ADC     #255
        STA     TXTPTR+1        ;SETUP TEXT POINTER.
        RTS
; SUBTTL        THE "LIST" COMMAND.

LIST:   BCC     GOLST           ;IT IS A DIGIT.
        BEQ     GOLST           ;IT IS A TERMINATOR.
        CMP     #MINUTK         ;DASH PRECEDING?
        BNE     STKRTS          ;NO, SO SYNTAX ERROR.
GOLST:  JSR     LINGET          ;GET LINE NUMBER INTO NUMLIN.
        JSR     FNDLIN          ;FIND LINE .GE. [NUMLIN].
        JSR     CHRGOT          ;GET LAST CHARACTER.
        BEQ     LSTEND          ;IF END OF LINE, # IS THE END.
        CMP     #MINUTK         ;DASH?
        BNE     FLNRTS          ;IF NOT, SYNTAX ERROR.
        JSR     CHRGET          ;GET NEXT CHAR.
        JSR     LINGET          ;GET END #.
        BNE     FLNRTS          ;IF NOT TERMINATOR, ERROR.
LSTEND: PLA
        PLA                     ;GET RID OF "NEWSTT" RTS ADDR.
        LDA     LINNUM          ;SEE IF IT WAS EXISTENT.
        ORA     LINNUM+1
        BNE     LIST4           ;IT WAS TYPED.
        LDA     #255
        STA     LINNUM
        STA     LINNUM+1        ;MAKE IT HUGE.
LIST4:  LDY     #1
        STY     DORES
        LDA     (LOWTR),Y               ;IS LINK ZERO?
        BEQ     GRODY           ;YES, GO TO READY.
        JSR     ISCNTC          ;LISTEN FOR CONT-C.
        JSR     CRDO            ;PRINT CRLF TO START WITH.
        INY
        LDA     (LOWTR),Y
        TAX
        INY
        LDA     (LOWTR),Y               ;GET LINE NUMBER.
        CMP     LINNUM+1        ;SEE IF BEYOND LAST.
        BNE     TSTDUN          ;GO DETERMINE RELATION.
        CPX     LINNUM          ;WAS EQUAL SO TEST LOW ORDER.
        BEQ     TYPLIN          ;EQUAL, SO LIST IT.
TSTDUN: BCS     GRODY           ;IF LINE IS GR THAN LAST, THEN DUNE.
TYPLIN: STY     LSTPNT
        JSR     LINPRT          ;PRINT AS INT WITHOUT LEADING SPACE.
        LDA     #' '            ;ALWAYS PRINT SPACE AFTER NUMBER.
PRIT4:  LDY     LSTPNT          ;GET POINTER TO LINE BACK.
        AND     #127
PLOOP:  JSR     OUTDO           ;PRINT CHAR.
        CMP     #34
        BNE     PLOOP1
        COM     DORES           ;IF QUOTE, COMPLEMENT FLAG.
PLOOP1: INY
        BEQ     GRODY           ;IF WE HAVE PRINTED 256 CHARACTERS
                                ;THE PROGRAM MUST BE MISFORMATED IN
                                ;MEMORY DUE TO A BAD LOAD OR BAD
                                ;HARDWARE. LET THE GUY RECOVER
        LDA     (LOWTR),Y               ;GET NEXT CHAR. IS IT ZERO?
        BNE     QPLOP           ;YES. END OF LINE.
        TAY
        LDA     (LOWTR),Y
        TAX
        INY
        LDA     (LOWTR),Y
        STX     LOWTR
        STA     LOWTR+1
        BNE     LIST4           ;BRANCH IF SOMETHING TO LIST.
GRODY:  JMP     READY
                                ;IS IT A TOKEN?
QPLOP:  BPL     PLOOP           ;NO, HEAD FOR PRINTER.
        CMP     #PI
        BEQ     PLOOP
        BIT     DORES           ;INSIDE QUOTE MARKS?
        BMI     PLOOP           ;YES, JUST TYPE THE CHARACTER.
        SEC
        SBC     #127            ;GET RID OF SIGN BIT AND ADD 1.
        TAX                     ;MAKE IT A COUNTER.
        STY     LSTPNT          ;SAVE POINTER TO LINE.
        LDY     #255            ;LOOK AT RES'D WORD LIST.
RESRCH: DEX                     ;IS THIS THE RES'D WORD?
        BEQ     PRIT3           ;YES, GO TOSS IT UP..
RESCR1: INY
        LDA     RESLST,Y        ;END OF ENTRY?
        BPL     RESCR1          ;NO, CONTINUE PASSING.
        BMI     RESRCH
PRIT3:  INY
        LDA     RESLST,Y
        BMI     PRIT4           ;END OF RESERVED WORD.
        JSR     OUTDO           ;PRINT IT.
        BNE     PRIT3           ;END OF ENTRY? NO, TYPE REST.
; SUBTTL THE "FOR" STATEMENT.
;
; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
;
; LOW ADDRESS
;       TOKEN (FORTK) 1 BYTE
;       A POINTER TO THE LOOP VARIABLE 2 BYTES
;       THE STEP 4+ADDPRC BYTES
;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
;       THE UPPER VALUE 4+ADDPRC BYTES
;       THE LINE NUMBER OF THE "FOR" STATEMENT 2 BYTES
;       A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
; HIGH ADDRESS
;
; TOTAL 16+2*ADDPRC BYTES.
;

FOR:    LDA     #128            ;DON'T RECOGNIZE
        STA     SUBFLG          ;SUBSCRIPTED VARIABLES.
        JSR     LET             ;READ THE VARIABLE AND ASSIGN IT
                                ;THE CORRECT INITIAL VALUE AND STORE
                                ;A POINTER TO THE VARIABLE IN VARPNT.
        JSR     FNDFOR          ;PNTR IS IN VARPNT, AND FORPNT.
        BNE     NOTOL           ;IF NO MATCH, DON'T ELIMINATE ANYTHING.
        TXA                     ;MAKE IT ARITHMETICAL.
        ADC     #FORSIZ-3       ;ELIMINATE ALMOST ALL.
        TAX                     ;NOTE C=1, THEN PLA, PLA.
        TXS                     ;MANIFEST.
NOTOL:  PLA                     ;GET RID OF NEWSTT RETURN ADDRESS
        PLA                     ;IN CASE THIS IS A TOTALLY NEW ENTRY.
        LDA     #8+ADDPRC
        JSR     GETSTK          ;MAKE SURE 16 BYTES ARE AVAILABLE.
        JSR     DATAN           ;GET A COUNT IN [Y] OF THE NUMBER OF
                                ;CHACRACTERS LEFT IN THE "FOR" STATEMENT
                                ;[TXTPTR] IS UNAFFECTED.
        CLC                     ;PREP TO ADD.
        TYA                     ;SAVE IT FOR PUSHING.
        ADC     TXTPTR
        PHA
        LDA     TXTPTR+1
        ADC     #0
        PHA
        PSHWD   CURLIN          ;PUT LINE NUMBER ON STACK.
        SYNCHK  TOTK            ;"TO" IS NECESSARY.
        JSR     CHKNUM          ;VALUE MUST BE A NUMBER.
        JSR     FRMNUM          ;GET UPPER VALUE INTO FAC.
        LDA     FACSGN          ;PACK FAC.
        ORA     #127
        AND     FACHO
        STA     FACHO           ;SET PACKED SIGN BIT.
        LDWDI   LDFONE
        STWD    INDEX1
        JMP     FORPSH          ;PUT FAC ONTO STACK, PACKED.
LDFONE: LDWDI   FONE            ;PUT 1.0 INTO FAC.
        JSR     MOVFM
        JSR     CHRGOT
        CMP     #STEPTK         ;A STEP IS GIVEN?
        BNE     ONEON           ;NO. ASSUME 1.0.
        JSR     CHRGET          ;YES. ADVANCE POINTER.
        JSR     FRMNUM          ;READ THE STEP.
ONEON:  JSR     SIGN            ;GET SIGN IN ACCA.
        JSR     PUSHF           ;PUSH FAC ONTO STACK (THRU A).
        PSHWD   FORPNT          ;PUT PNTR TO VARIABLE ON STACK.
NXTCON: LDA     #FORTK          ;PUT A FORTK ONTO STACK.
        PHA
;       BNEA    NEWSTT          ;SIMULATE BNE TO NEWSTT. JUST FALL IN.
; SUBTTL        NEW STATEMENT FETCHER.
;
; BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY TXTPTR
; IS ":" OR END-OF-LINE. THE ADDRESS OF THIS LOC IS LEFT
; ON THE STACK WHEN A STATEMENT IS EXECUTED SO THAT
; IT CAN MERELY DO A RTS WHEN IT IS DONE.
;
NEWSTT:
        JSR     ISCNTC          ;LISTEN FOR CONTROL-C.
        LDWD    TXTPTR          ;LOOK AT CURRENT CHARACTER.
        CPY     #BUFPAG         ;SEE IF IT WAS DIRECT BY CHECK FOR BUF'S PAGE NUMBER
        NOP
        BEQ     DIRCON
        STWD    OLDTXT          ;SAVE IN CASE OF RESTART BY INPUT.
DIRCON:
        LDY     #0
        LDA     (TXTPTR),Y
        BNE     MORSTS          ;NOT NULL -- CHECK WHAT IT IS
        LDY     #2              ;LOOK AT LINK.
        LDA     (TXTPTR),Y              ;IS LINK 0?
        CLC             ;CLEAR CARRY FOR ENDCON AND MATH THAT FOLLOWS
        JEQ     ENDCON          ;YES - RAN OFF THE END.
        INY                     ;PUT LINE NUMBER IN CURLIN.
        LDA     (TXTPTR),Y
        STA     CURLIN
        INY
        LDA     (TXTPTR),Y
        STA     CURLIN+1
        TYA
        ADC     TXTPTR
        STA     TXTPTR
        BCC     GONE
        INC     TXTPTR+1
GONE:   JSR     CHRGET          ;GET THE STATEMENT TYPE.
        JSR     GONE3
        JMP     NEWSTT
GONE3:  BEQ     ISCRTS          ;IF TERMINATOR, TRY AGAIN.
                                ;NO NEED TO SET UP CARRY SINCE IT WILL
                                ;BE ON IF NON-NUMERIC AND NUMERICS
                                ;WILL CAUSE A SYNTAX ERROR LIKE THEY SHOULD
GONE2:  SBC     #ENDTK          ;" ON ... GOTO AND GOSUB" COME HERE.
        BCC     GLET
        CMP     #SCRATK-ENDTK+1
        BCS     SNERRX          ;SOME RES'D WORD BUT NOT
                                ;A STATEMENT RES'D WORD.
        ASL     A               ;MULTIPLY BY TWO.
        TAY                     ;MAKE AN INDEX.
        LDA     STMDSP+1,Y
        PHA
        LDA     STMDSP,Y
        PHA                     ;PUT DISP ADDR ONTO STACK.
        JMP     CHRGET
GLET:   JMP     LET             ;MUST BE A LET
MORSTS: CMP     #':'
        BEQ     GONE            ;IF A ":" CONTINUE STATEMENT
SNERR1: JMP     SNERR           ;NEITHER 0 OR ":" SO SYNTAX ERROR
SNERRX: CMP     #GOTK-ENDTK
        BNE     SNERR1
        JSR     CHRGET          ;READ IN THE CHARACTER AFTER "GO "
        SYNCHK  TOTK
        JMP     GOTO
; SUBTTL        RESTORE,STOP,END,CONTINUE,NULL,CLEAR.

RESTOR: SEC
        LDA     TXTTAB
        SBC     #1
        LDY     TXTTAB+1
        BCS     RESFIN
        DEY
RESFIN: STWD    DATPTR          ;READ FINISHES COME TO "RESFIN".
ISCRTS: RTS


STOP:   BCS     STOPC           ;MAKE [C] NONZERO AS A FLAG.
END:    CLC
STOPC:  BNE     CONTRT          ;RETURN IF NOT CONT-C OR
                                ;IF NO TERMINATOR FOR STOP OR END.
                                ;[C]=0 SO WILL NOT PRINT "BREAK".
        LDWD    TXTPTR
        LDX     CURLIN+1
        INX
        BEQ     DIRIS
        STWD    OLDTXT
STPEND: LDWD    CURLIN
        STWD    OLDLIN
DIRIS:  PLA                     ;POP OFF NEWSTT ADDR.
        PLA
ENDCON: LDWDI   BRKTXT
        LDX     #0
        STX     CNTWFL
        BCC     GORDY           ;CARRY CLEAR SO DON'T PRINT "BREAK".
        JMP     ERRFIN
GORDY:  JMP     READY           ;TYPE "READY".

CONT:   BNE     CONTRT          ;MAKE SURE THERE IS A TERMINATOR.
        LDX     #ERRCN          ;CONTINUE ERROR.
        LDY     OLDTXT+1        ;A STORED TXTPTR OF ZERO IS SETUP
                                ;BY STKINI AND INDICATES THERE IS
                                ;NOTHING TO CONTINUE.
        JEQ     ERROR           ;"STOP", "END", TYPING CRLF TO 
                                ;"INPUT" AND  ^C SETUP OLDTXT.
        LDA     OLDTXT
        STWD    TXTPTR
        LDWD    OLDLIN
        STWD    CURLIN
CONTRT: RTS                     ;RETURN TO CALLER.

; SUBTTL        LOAD AND SAVE SUBROUTINES.

; SUBTTL        RUN,GOTO,GOSUB,RETURN.
RUN:    JEQ     RUNC            ;IF NO LINE # ARGUMENT.
        JSR     CLEARC          ;CLEAN UP -- RESET THE STACK.
        JMP     RUNC2           ;MUST REPLACE RTS ADDR.
;
; A GOSUB ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
;
; LOW ADDRESS:
;       THE GOSUTK ONE BYTE
;       THE LINE NUMBER OF THE GOSUB STATEMENT TWO BYTES
;       A POINTER INTO THE TEXT OF THE GOSUB TWO BYTES
;
; HIGH ADDRESS.
;
; TOTAL FIVE BYTES.
;
GOSUB:  LDA     #3
        JSR     GETSTK          ;MAKE SURE THERE IS ROOM.
        PSHWD   TXTPTR          ;PUSH ON THE TEXT POINTER.
        PSHWD   CURLIN          ;PUSH ON THE CURRENT LINE NUMBER.
        LDA     #GOSUTK
        PHA                     ;PUSH ON A GOSUB TOKEN.
RUNC2:  JSR     CHRGOT          ;GET CHARACTER AND SET CODES FOR LINGET.
        JSR     GOTO            ;USE RTS SCHEME TO "NEWSTT".
        JMP     NEWSTT

GOTO:   JSR     LINGET          ;PICK UP THE LINE NUMBER IN "LINNUM".
        JSR     REMN            ;SKIP TO END OF LINE.
        LDA     CURLIN+1
        CMP     LINNUM+1
        BCS     LUK4IT
        TYA
        SEC
        ADC     TXTPTR
        LDX     TXTPTR+1
        BCC     LUKALL
        INX
        BCSA    LUKALL          ;ALWAYS GOES.
LUK4IT: LDWX    TXTTAB
LUKALL: JSR     FNDLNC          ;[X,A] ARE ALL SET UP.
QFOUND: BCC     USERR           ;GOTO LINE IS NONEXISTANT.
        LDA     LOWTR
        SBC     #1
        STA     TXTPTR
        LDA     LOWTR+1
        SBC     #0
        STA     TXTPTR+1
GORTS:  RTS                     ;PROCESS THE STATEMENT.
;
; "RETURN" RESTORES THE LINE NUMBER AND TEXT PNTR FROM THE STACK
; AND ELIMINATES ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB" ENTRY.
;
RETURN: BNE     GORTS           ;NO TERMINATOR=BLOW HIM UP.
        LDA     #255
        STA     FORPNT+1        ;MAKE SURE THE VARIABLE'S PNTR
                                ;NEVER GETS MATCHED.
        JSR     FNDFOR          ;GO PAST ALL THE "FOR" ENTRIES.
        TXS
        CMP     #GOSUTK         ;RETURN WITHOUT GOSUB?
        BEQ     RETU1
        LDX     #ERRRG
        SKIP2
USERR:  LDX     #ERRUS          ;NO MATCH SO "US" ERROR.
        JMP     ERROR           ;YES.
SNERR2: JMP     SNERR
RETU1:  PLA                     ;REMOVE GOSUTK.
        PULWD   CURLIN          ;GET LINE NUMBER "GOSUB" WAS FROM.
        PULWD   TXTPTR          ;GET TEXT PNTR FROM "GOSUB".
DATA:   JSR     DATAN           ;SKIP TO END OF STATEMENT, 
                                ;SINCE WHEN "GOSUB" STUCK THE TEXT  PNTR
                                ;ONTO THE STACK, THE LINE NUMBER ARG
                                ;HADN'T BEEN READ YET.
ADDON:  TYA
        CLC
        ADC     TXTPTR
        STA     TXTPTR
        BCC     REMRTS
        INC     TXTPTR+1
REMRTS: RTS                     ;"NEWSTT" RTS ADDR IS STILL THERE.

DATAN:  LDX     #':'            ;"DATA" TERMINATES ON ":" AND NULL.
        SKIP2
REMN:   LDX     #0              ;THE ONLY TERMINATOR IS NULL.
        STX     CHARAC          ;PRESERVE IT.
        LDY     #0              ;THIS MAKES CHARAC=0 AFTER SWAP.
        STY     ENDCHR
EXCHQT: LDA     ENDCHR
        LDX     CHARAC
        STA     CHARAC
        STX     ENDCHR
REMER:  LDA     (TXTPTR),Y
        BEQ     REMRTS          ;NULL ALWAYS TERMINATES.
        CMP     ENDCHR          ;IS IT THE OTHER TERMINATOR?
        BEQ     REMRTS          ;YES, IT'S FINISHED.
        INY                     ;PROGRESS TO NEXT CHARACTER.
        CMP     #34             ;IS IT A QUOTE?
        BNE     REMER           ;NO, JUST CONTINUE.
        BEQA    EXCHQT          ;YES, TIME TO TRADE.
; SUBTTL        "IF ... THEN" CODE.
IF:     JSR     FRMEVL          ;EVALUATE A FORMULA.
        JSR     CHRGOT          ;GET CURRENT CHARACTER.
        CMP     #GOTOTK         ;IS TERMINATING CHARACTER A GOTOTK?
        BEQ     OKGOTO          ;YES.
        SYNCHK  THENTK          ;NO, IT MUST BE "THEN".
OKGOTO: LDA     FACEXP          ;0=FALSE. ALL OTHERS TRUE.
        BNE     DOCOND          ;TRUE !
REM:    JSR     REMN            ;SKIP REST OF STATEMENT.
        BEQA    ADDON           ;WILL ALWAYS BRANCH.
DOCOND: JSR     CHRGOT          ;TEST CURRENT CHARACTER.
        BCS     DOCO            ;IF A NUMBER, GOTO IT.
        JMP     GOTO
DOCO:   JMP     GONE3           ;INTERPRET NEW STATEMENT.
; SUBTTL        "ON ... GO TO ..." CODE.
ONGOTO: JSR     GETBYT          ;GET VALUE IN FACLO.
        PHA                     ;SAVE FOR LATER.
        CMP     #GOSUTK         ;AN "ON ... GOSUB" PERHAPS?
        BEQ     ONGLOP          ;YES.
SNERR3: CMP     #GOTOTK         ;MUST BE "GOTOTK".
        BNE     SNERR2
ONGLOP: DEC     FACLO
        BNE     ONGLP1          ;SKIP ANOTHER LINE NUMBER.
        PLA                     ;GET DISPATCH CHARACTER.
        JMP     GONE2
ONGLP1: JSR     CHRGET          ;ADVANCE AND SET CODES.
        JSR     LINGET
        CMP     #44             ;IS IT A COMMA?
        BEQ     ONGLOP
        PLA                     ;REMOVE STACK ENTRY (TOKEN).
ONGRTS: RTS                     ;EITHER END-OF-LINE OR SYNTAX ERROR.
; SUBTTL        LINGET -- READ A LINE NUMBER INTO LINNUM
;
; "LINGET" READS A LINE NUMBER FROM THE CURRENT TEXT POSITION.
;
; LINE NUMBERS RANGE FROM 0 TO 64000-1.
;
; THE ANSWER IS RETURNED IN "LINNUM".
; "TXTPTR" IS UPDATED TO POINT TO THE TERMINATING CHARCTER
; AND [A] = THE TERMINATING CHARACTER WITH CONDITION
; CODES SET UP TO REFLECT ITS VALUE.
;
LINGET: LDX     #0
        STX     LINNUM          ;INITIALIZE LINE NUMBER TO ZERO.
        STX     LINNUM+1
MORLIN: BCS     ONGRTS          ;IT IS NOT A DIGIT.
        SBC     #'0'-1          ;-1 SINCE C=0.
        STA     CHARAC          ;SAVE CHARACTER.
        LDA     LINNUM+1
        STA     INDEX
        CMP     #25             ;LINE NUMBER WILL BE .LT. 64000?
        BCS     SNERR3
        LDA     LINNUM
        ASL     A               ;MULTIPLY BY 10.
        ROL     INDEX
        ASL     A
        ROL     INDEX
        ADC     LINNUM
        STA     LINNUM
        LDA     INDEX
        ADC     LINNUM+1
        STA     LINNUM+1
        ASL     LINNUM
        ROL     LINNUM+1
        LDA     LINNUM
        ADC     CHARAC          ;ADD IN DIGIT.
        STA     LINNUM
        BCC     NXTLGC
        INC     LINNUM+1
NXTLGC: JSR     CHRGET
        JMP     MORLIN

; SUBTTL        "LET" CODE.
LET:    JSR     PTRGET          ;GET PNTR TO VARIABLE INTO "VARPNT".
        STWD    FORPNT          ;PRESERVE POINTER.
        SYNCHK  EQULTK          ;"=" IS NECESSARY.
        LDA     INTFLG          ;SAVE FOR LATER.
        PHA
        LDA     VALTYP          ;RETAIN THE VARIABLE'S VALUE TYPE.
        PHA
        JSR     FRMEVL          ;GET VALUE OF FORMULA INTO "FAC".
        PLA
        ROL     A               ;CARRY SET FOR STRING, OFF FOR
                                ;NUMERIC.
        JSR     CHKVAL          ;MAKE SURE "VALTYP" MATCHES CARRY.
                                ;AND SET ZERO FLAG FOR NUMERIC.
        BNE     COPSTR          ;IF NUMERIC, COPY IT.
COPNUM:
        PLA                     ;GET NUMBER TYPE.
QINTGR: BPL     COPFLT          ;STORE A FLTING NUMBER.
        JSR     ROUND           ;ROUND INTEGER.
        JSR     AYINT           ;MAKE 2-BYTE NUMBER.
        LDY     #0
        LDA     FACMO           ;GET HIGH.
        STA     (FORPNT),Y              ;STORE IT.
        INY
        LDA     FACLO           ;GET LOW.
        STA     (FORPNT),Y
        RTS
COPFLT: JMP     MOVVF           ;PUT NUMBER @FORPNT.

COPSTR:
PLA             ;IF STRING, NO INTFLG.
INPCOM:
        LDY     FORPNT+1        ;TI$?
        CPY     #ZERO/256       ;ONLY TI$ CAN BE THIS ON ASSIG.
        BNE     GETSPT          ; WAS NOT TI$.
        JSR     FREFAC          ;WE WONT NEEDIT.
        CMP     #6              ;LENGTH CORRECT?
        BNE     FCERR2
        LDY     #0              ;YES. DO SETUP.
        STY     FACEXP          ;ZERO FAC TO START WITH.
        STY     FACSGN
TIMELP: STY     FBUFPT          ;SAVE POSOTION.
        JSR     TIMNUM          ;GET A DIGIT.
        JSR     MUL10           ;WHOLE QTY BY 10.
        INC     FBUFPT
        LDY     FBUFPT
        JSR     TIMNUM
        JSR     MOVAF
        TAX                     ;IF NUM=0 THEN NO MULT.
        BEQ     NOML6           ;IF =0, GO TIT.
        INX                     ;MULT BY TWO.
        TXA
        JSR     FINML6          ;ADD IN AND MULT BY 2 GIVES *6.
NOML6:  LDY     FBUFPT
        INY
        CPY     #6              ;DONE ALL SIX?
        BNE     TIMELP
        JSR     MUL10           ;ONE LAST TIME.
        JSR     QINT            ;SHIFT IT OVER TO THE RIGHT.
        LDX     #2
        SEI                     ;DISALLOW INTERRUPTS.
TIMEST: LDA     FACMOH,X
        STA     CQTIMR,X
        DEX
        BPL     TIMEST          ;LOOP 3 TIMES.
        CLI                     ;TURN ON INTS AGAIN.
        RTS
TIMNUM: LDA     (INDEX),Y               ;INDEX SET UP BY FREFAC.
        JSR     QNUM
        BCC     GOTNUM
FCERR2: JMP     FCERR           ;MUST BE NUMERIC STRING.
GOTNUM: SBC     #'0'-1          ;C IS OFF.
        JMP     FINLOG          ;ADD IN DIGIT TO FAC.

GETSPT: LDY     #2              ;GET PNTR TO DESCRIPTOR.
        LDA     (FACMO),Y
        CMP     FRETOP+1        ;SEE IF IT POINTS INTO STRING SPACE.
        BCC     DNTCPY          ;IF [FRETOP],GT.[2&3,FACMO], DON'T COPY.
        BNE     QVARIA          ;IT IS LESS.
        DEY
        LDA     (FACMO),Y
        CMP     FRETOP          ;COMPARE LOW ORDERS.
        BCC     DNTCPY
QVARIA: LDY     FACLO
        CPY     VARTAB+1        ;IF [VARTAB].GT.[FACMO], DON'T COPY.
        BCC     DNTCPY
        BNE     COPY            ;IT IS LESS.
        LDA     FACMO
        CMP     VARTAB          ;COMPARE LOW ORDERS.
        BCS     COPY
DNTCPY: LDWD    FACMO
        JMP     COPYZC
COPY:   LDY     #0
        LDA     (FACMO),Y
        JSR     STRINI          ;GET ROOM TO COPY STRING INTO.
        LDWD    DSCPNT          ;GET POINTER TO OLD DESCRIPTOR, SO 
        STWD    STRNG1          ;MOVINS CAN FIND STRING.
        JSR     MOVINS          ;COPY IT.
        LDWDI   DSCTMP          ;GET POINTER TO OLD DESCRIPTOR.
COPYZC: STWD    DSCPNT          ;REMEMBER POINTER TO DESCRIPTOR.
        JSR     FRETMS          ;FREE UP THE TEMPORARY WITHOUT
                                ;FREEING UP ANY STRING SPACE.
        LDY     #0
        LDA     (DSCPNT),Y
        STA     (FORPNT),Y
        INY                     ;POINT TO STRING PNTR.
        LDA     (DSCPNT),Y
        STA     (FORPNT),Y
        INY
        LDA     (DSCPNT),Y
        STA     (FORPNT),Y
        RTS
; SUBTTL        PRINT CODE.
PRINTN: JSR     CMD             ;DOCMD
        JMP     IODONE          ;RELEASE CHANNEL.
CMD:    JSR     GETBYT
        BEQ     SAVEIT
        SYNCHK  44              ;COMMA?
SAVEIT: PHP
        JSR     CQOOUT          ;CHECK AND OPEN OUTPUT CHANNL.
        STX     CHANNL          ;CHANNL TO OUTPUT ON.
        PLP                     ;GET STATUS BACK.
        JMP     PRINT
STRDON: JSR     STRPRT
NEWCHR: JSR     CHRGOT          ;REGET LAST CHARACTER.
PRINT:  BEQ     CRDO            ;TERMINATOR SO TYPE CRLF.
PRINTC: BEQ     PRTRTS          ;HERE AFTER SEEING TAB(X) OR , OR ;
                                ;IN WHICH CASE A TERMINATOR DOES NOT
                                ;MEAN TYPE A CRLF BUT JUST RTS.
        CMP     #TABTK          ;TAB FUNCTION?
        BEQ     TABER           ;YES.
        CMP     #SPCTK          ;SPACE FUNCTION?
        CLC
        BEQ     TABER
        CMP     #44             ;A COMMA?
        BEQ     COMPRT          ;YES.
        CMP     #59             ;A SEMICOLON?
        BEQ     NOTABR          ;YES.
        JSR     FRMEVL          ;EVALUATE THE FORMULA.
        BIT     VALTYP          ;A STRING?
        BMI     STRDON          ;YES.
        JSR     FOUT
        JSR     STRLIT          ;BUILD DESCRIPTOR.
LINCHK: JSR     STRPRT          ;PRINT THE NUMBER.
        JSR     OUTSPC          ;PRINT A SPACE
        BNEA    NEWCHR          ;ALWAYS GOES.
FININL: LDA     #0
        STA     BUF,X
        LDXYI   BUF-1
        LDA     CHANNL          ;NO CRDO IF NOT TERMINAL.
        BNE     PRTRTS
CRDO:
GOCR:   LDA     #13             ;X AND Y MUST BE PRESERVED.
        JSR     OUTDO
        LDA     #10
        JSR     OUTDO
CRFIN:
        EOR     #255
PRTRTS: RTS

COMPRT: LDA     TRMPOS
NCMPOS=(((LINLEN/CLMWID)-1)*CLMWID)     ;CLMWID BEYOND WHICH THERE ARE
MORCOM: SEC
MORCO1: SBC     #CLMWID         ;GET [A] MODULUS CLMWID.
        BCS     MORCO1
        EOR     #255            ;FILL PRINT POS OUT TO EVEN CLMWID SO
        ADC     #1
        BNE     ASPAC           ;PRINT [A] SPACES.

TABER:  PHP                     ;REMEMBER IF SPC OR TAB FUNCTION.
        JSR     GTBYTC          ;GET VALUE INTO ACCX.
        CMP     #41
        BNE     SNERR4
        PLP
        BCC     XSPAC           ;PRINT [X] SPACES.
        TXA
        SBC     TRMPOS
        BCC     NOTABR          ;NEGATIVE, DON'T PRINT ANY.
ASPAC:  TAX
XSPAC:  INX
XSPAC2: DEX                     ;DECREMENT THE COUNT.
        BNE     XSPAC1
NOTABR: JSR     CHRGET          ;REGET LAST CHARACTER.
        JMP     PRINTC          ;DON'T CALL CRDO.
XSPAC1: JSR     OUTSPC
        BNEA    XSPAC2
;
; PRINT THE STRING POINTED TO BY [Y,A] WHICH ENDS WITH A ZERO.
; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE.
;
STROUT: JSR     STRLIT          ;GET A STRING LITERAL.
;
; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACMO.
;
STRPRT: JSR     FREFAC          ;RETURN TEMP POINTER.
        TAX                     ;PUT COUNT INTO COUNTER.
        LDY     #0
        INX                     ;MOVE ONE AHEAD.
STRPR2: DEX
        BEQ     PRTRTS          ;ALL DONE.
        LDA     (INDEX),Y               ;PNTR TO ACT STRNG SET BY FREFAC.
        JSR     OUTDO
        INY
        CMP     #13
        BNE     STRPR2
        JSR     CRFIN           ;TYPE REST OF CARRIAGE RETURN.
        JMP     STRPR2          ;AND ON AND ON.
;
; OUTDO OUTPUTS THE CHARACTER IN ACCA, USING CNTWFL
; (SUPPRESS OR NOT), TRMPOS (PRINT HEAD POSITION),
; TIMING, ETCQ. NO REGISTERS ARE CHANGED.
;
OUTSPC:
        LDA     CHANNL
        BEQ     CRTSKP
        LDA     #' '
        SKIP2
CRTSKP: LDA     #29             ;COMMODORE'S SKIP CHARACTER.
        SKIP2
OUTQST: LDA     #'?'
OUTDO:
        BIT     CNTWFL          ;SHOULDN'T AFFECT CHANNEL I/O!
        BMI     OUTRTS

OUTLOC: JSR     OUTCH           ;OUTPUT THE CHARACTER.

OUTRTS: AND     #255            ;SET Z=0.
GETRTS: RTS

; SUBTTL        INPUT AND READ CODE.
;
; HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
; IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
; FOR "READ" WE GIVE A SYNTAX ERROR AT THE DATA LINE.
;
TRMNOK: LDA     INPFLG
        BEQ     TRMNO1          ;IF INPUT TRY AGAIN.
        BMI     GETDTL
        LDY     #255            ;MAKE IT LOOK DIRECT.
        BNEA    STCURL          ;ALWAYS GOES.
GETDTL:
        LDWD    DATLIN          ;GET DATA LINE NUMBER.
STCURL: STWD    CURLIN          ;MAKE IT CURRENT LINE.
SNERR4: JMP     SNERR
TRMNO1:
        LDA     CHANNL          ;IF NOT TERMINAL, GIVE BAD DATA.
        BEQ     DOAGIN
        LDX     #ERRBD
        JMP     ERROR
DOAGIN: LDWDI   TRYAGN
        JSR     STROUT          ;PRINT "?REDO FROM START".
        LDWD    OLDTXT          ;POINT AT START
        STWD    TXTPTR          ;OF THIS CURRENT LINE.
        RTS                     ;GO TO "NEWSTT".
GET:    JSR     ERRDIR          ;DIRECT IS NOT OK.
        CMP     #'#'            ;SEE IF "GET#".
        BNE     GETTTY          ;NO, JUST GET TTY INPUT.
        JSR     CHRGET          ;MOVE UP TO NEXT BYTE.
        JSR     GETBYT          ;GET CHANNEL INTO X
        SYNCHK  44              ;COMMA?
        JSR     CQOIN           ;GET CHANNEL OPEN FOR INPUT.
        STX     CHANNL
GETTTY: LDXYI   BUF+1           ;POINT TO 0.
        LDA     #0              ;TO STUFF AND TO POINT.
        STA     BUF+1
        LDA     #64             ;TURN ON V-BIT.
        JSR     INPCO1          ;DO THE GET.
        LDX     CHANNL
        BNE     IORELE          ;RELEASE.
        RTS

INPUTN: JSR     GETBYT          ;GET CHANNEL NUMBER.
        SYNCHK  44              ;A COMMA?
        JSR     CQOIN           ;GO WHERE COMMODORE CHECKS IN OPEN.
        STX     CHANNL
        JSR     NOTQTI          ;DO INPUT TO VARIABLES.
IODONE: LDA     CHANNL          ;RELEASE CHANNEL.
IORELE: JSR     CQCCHN
        LDX     #0              ;RESET CHANNEL TO TERMINAL.
        STX     CHANNL
        RTS
INPUT:
        LSR     CNTWFL          ;BE TALKATIVE.
        CMP     #34             ;A QUOTE?
        BNE     NOTQTI          ;NO MESSAGE.
        JSR     STRTXT          ;LITERALIZE THE STRING IN TEXT
        SYNCHK  59              ;MUST END WITH SEMICOLON.
        JSR     STRPRT          ;PRINT IT OUT.
NOTQTI: JSR     ERRDIR          ;USE COMMON ROUTINE SINCE DEF DIRECT
        LDA     #44             ;GET COMMA.
        STA     BUF-1
                                ;IS ALSO ILLEGAL.
GETAGN: JSR     QINLIN          ;TYPE "?" AND INPUT A LINE OF TEXT.
        LDA     CHANNL
        BEQ     BUFFUL
        LDA     CQSTAT          ;GET STATUS BYTE.
        AND     #2
        BEQ     BUFFUL          ;A-OK.
        JSR     IODONE          ;BAD. CLOSE CHANNEL.
        JMP     DATA            ;SKIP REST OF INPUT.
BUFFUL:
        LDA     BUF             ;ANYTHING INPUT?
        BNE     INPCON          ;YES, CONTINUE.
        LDA     CHANNL          ;BLANK LINE MEANS GET ANOTHER.
        BNE     GETAGN          ;IF NOT TERMINAL.
        CLC                     ;MAKE SURE DONT PRINT BREAK
        JMP     STPEND          ;NO, STOP.
QINLIN:
        LDA     CHANNL
        BNE     GINLIN
        JSR     OUTQST
        JSR     OUTSPC
GINLIN: JMP     INLIN
READ:   LDXY    DATPTR          ;GET LAST DATA LOCATION.
        .BYTE   $A9
        TYA
        SKIP2
INPCON: LDA     #0              ;SET FLAG THAT THIS IS INPUT
INPCO1: STA     INPFLG          ;STORE THE FLAG.
;
; IN THE PROCESSING OF DATA AND READ STATEMENTS:
; ONE POINTER POINTS TO THE DATA (IE, THE NUMBERS BEING FETCHED)
; AND ANOTHER POINTS TO THE LIST OF VARIABLES.
;
; THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
; TERMINATOR -- A , : OR END-OF-LINE.
;
; AT THIS POINT TXTPTR POINTS TO LIST OF VARIABLES AND
; [Y,X] POINTS TO DATA OR INPUT LINE.
;
        STXY    INPPTR
INLOOP: JSR     PTRGET          ;READ VARIABLE LIST.
        STWD    FORPNT          ;SAVE POINTER FOR "LET" STRING STUFFING.
                                ;RETURNS PNTR TOP VAR IN VARPNT.
        LDWD    TXTPTR          ;SAVE TEXT PNTR.
        STWD    VARTXT
        LDXY    INPPTR
        STXY    TXTPTR
        JSR     CHRGOT          ;GET IT AND SET Z IF TERM.
        BNE     DATBK1
        BIT     INPFLG
        BVC     QDATA
        JSR     CZGETL          ;DON'T WANT INCHR. JUST ONE.
        STA     BUF             ;MAKE IT FIRST CHARACTER.
        LDXYI   (BUF-1)         ;POINT JUST BEFORE IT.
        BNEA    DATBK           ;GO PROCESS.
QDATA:  BMI     DATLOP          ;SEARCH FOR ANOTHER DATA STATEMENT.
        LDA     CHANNL
        BNE     GETNTH
        JSR     OUTQST
GETNTH: JSR     QINLIN          ;GET ANOTHER LINE.
DATBK:  STXY    TXTPTR          ;SET FOR "CHRGET".
DATBK1: JSR     CHRGET
        BIT     VALTYP          ;GET VALUE TYPE.
        BPL     NUMINS          ;INPUT A NUMBER IF NUMERIC.
        BIT     INPFLG          ;GET?
        BVC     SETQUT          ;NO, GO SET QUOTE.
        INX
        STX     TXTPTR
        LDA     #0              ;ZERO TERMINATORS.
        STA     CHARAC
        BEQA    RESETC
SETQUT: STA     CHARAC          ;ASSUME QUOTED STRING.
        CMP     #34             ;TERMINATORS OK?
        BEQ     NOWGET          ;YES.
        LDA     #':'            ;SET TERMINATORS TO ":" AND
        STA     CHARAC
        LDA     #44             ;COMMA.
RESETC: CLC
NOWGET: STA     ENDCHR
        LDWD    TXTPTR
        ADC     #0              ;C IS SET PROPERLY ABOVE.
        BCC     NOWGE1
        INY
NOWGE1: JSR     STRLT2          ;MAKE A STRING DESCRIPTOR FOR THE VALUE
                                ;AND COPY IF NECESSARY.
        JSR     ST2TXT          ;SET TEXT POINTER.
        JSR     INPCOM          ;DO ASSIGNMENT.
        JMP     STRDN2
NUMINS: JSR     FIN
        LDA     INTFLG          ;SET CODES ON FLAG.
        JSR     QINTGR          ;GO DECIDE ON FLOAT.
STRDN2: JSR     CHRGOT          ;READ LAST CHARACTER.
        BEQ     TRMOK           ;":" OR EOL IS OK.
        CMP     #44             ;A COMMA?
        JNE     TRMNOK
TRMOK:  LDWD    TXTPTR
        STWD    INPPTR          ;SAVE FOR MORE READS.
        LDWD    VARTXT
        STWD    TXTPTR          ;POINT TO VARIABLE LIST.
        JSR     CHRGOT          ;LOOK AT LAST VARIABLE LIST CHARACTER.
        BEQ     VAREND          ;THAT'S THE END OF THE LIST.
        JSR     CHKCOM          ;NOT END. CHECK FOR COMMA.
        JMP     INLOOP
;
; SUBROUTINE TO FIND DATA
; THE SEARCH IS MADE BY USING THE EXECUTION CODE FOR DATA TO
; SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
; IS COMPARED WITH "DATATK". EACH NEW LINE NUMBER
; IS STORED IN "DATLIN" SO THAT IF AN ERROR OCCURS
; WHILE READING DATA THE ERROR MESSAGE CAN GIVE THE LINE
; NUMBER OF THE ILL-FORMATTED DATA.
;
DATLOP: JSR     DATAN           ;SKIP SOME TEXT.
        INY
        TAX                     ;END OF LINE?
        BNE     NOWLIN          ;SHO AIN'T.
        LDX     #ERROD          ;YES = "NO DATA" ERROR.
        INY
        LDA     (TXTPTR),Y
        BEQ     ERRGO5
        INY
        LDA     (TXTPTR),Y              ;GET HIGH BYTE OF LINE NUMBER.
        STA     DATLIN
        INY
        LDA     (TXTPTR),Y              ;GET LOW BYTE.
        INY
        STA     DATLIN+1
NOWLIN: LDA     (TXTPTR),Y              ;HOW IS IT?
        TAX
        JSR     ADDON           ;ADD [Y] TO [TXTPTR].
        CPX     #DATATK         ;IS IT A "DATA" STATEMENT.
        BNE     DATLOP          ;NOT QUITE RIGHT. KEEP LOOKING.
        JMP     DATBK1          ;THIS IS THE ONE !
VAREND: LDWD    INPPTR          ;PUT AWAY A NEW DATA PNTR MAYBE.
        LDX     INPFLG
        BPL     VARY0
        JMP     RESFIN
VARY0:  LDY     #0
        LDA     (INPPTR),Y              ;LAST DATA CHR COULD HAVE BEEN
                                ;COMMA OR COLON BUT SHOULD BE NULL.
        BEQ     INPRTS          ;IT IS NULL.
        LDA     CHANNL          ;IF NOT TERMINAL, NO TYPE.
        BNE     INPRTS
        LDWDI   EXIGNT
        JMP     STROUT          ;TYPE "?EXTRA IGNORED"
INPRTS: RTS                     ;DO NEXT STATEMENT.
EXIGNT: DT"?EXTRA IGNORED"
        ACRLF
        .BYTE 0
TRYAGN: DT"?REDO FROM START"
        ACRLF
        .BYTE 0
; SUBTTL        THE NEXT CODE IS THE "NEXT CODE"
;
; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
;
; LOW ADDRESS
;       TOKEN (FORTK) 1 BYTE
;       A POINTER TO THE LOOP VARIABLE 2 BYTES
;       THE STEP 4+ADDPRC BYTES
;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
;       THE UPPER VALUE (PACKED) 4+ADDPRC BYTES
;       THE LINE NUMBER OF THE "FOR" STATEMENT 2 BYTES
;       A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
; HIGH ADDRESS
;
; TOTAL 16+2*ADDPRC BYTES.
;
NEXT:   BNE     GETFOR
        LDY     #0              ;WITHOUT ARG CALL "FNDFOR" WITH
        BEQA    STXFOR          ;[FORPNT]=0.
GETFOR: JSR     PTRGET          ;GET A POINTER TO LOOP VARIABLE
STXFOR: STWD    FORPNT          ;INTO "FORPNT".
        JSR     FNDFOR          ;FIND THE MATCHING ENTRY IF ANY.
        BEQ     HAVFOR
        LDX     #ERRNF          ;"NEXT WITHOUT FOR".
ERRGO5: BEQ     ERRGO4
HAVFOR: TXS                     ;SETUP STACK. CHOP FIRST.
        TXA
        CLC
        ADC     #4              ;POINT TO INCREMENT
        PHA                     ;SAVE THIS POINTER TO RESTORE TO [A]
        ADC     #5+ADDPRC       ;POINT TO UPPER LIMIT
        STA     INDEX2          ;SAVE AS INDEX
        PLA                     ;RESTORE POINTER TO INCREMENT
        LDY     #1              ;SET HI ADDR OF THING TO MOVE.
        JSR     MOVFM           ;GET QUANTITY INTO THE FAC.
        TSX
        LDA     257+7+ADDPRC,X ;SET SIGN CORRECTLY.
        STA     FACSGN
        LDWD    FORPNT
        JSR     FADD            ;ADD INC TO LOOP VARIABLE.
        JSR     MOVVF           ;PACK THE FAC INTO MEMORY.
        LDY     #1
        JSR     FCOMPN          ;COMPARE FAC WITH UPPER VALUE.
        TSX
        SEC
        SBC     257+7+ADDPRC,X ;SUBTRACT SIGN OF INC FROM SIGN OF
                                ;OF (CURRENT VALUE-FINAL VALUE).
        BEQ     LOOPDN          ;IF SIGN (FINAL-CURRENT)-SIGN STEP=0
                                ;THEN LOOP IS DONE.
        LDA     2*ADDPRC+12+257,X
        STA     CURLIN          ;STORE LINE NUMBER OF "FOR" STATEMENT.
        LDA     257+13+(2*ADDPRC),X
        STA     CURLIN+1
        LDA     2*ADDPRC+15+257,X
        STA     TXTPTR          ;STORE TEXT PNTR INTO "FOR" STATEMENT.
        LDA     2*ADDPRC+14+257,X
        STA     TXTPTR+1
NEWSGO: JMP     NEWSTT          ;PROCESS NEXT STATEMENT.
LOOPDN: TXA
        ADC     #2*ADDPRC+15            ;ADDS 16 WITH CARRY.
        TAX
        TXS                     ;NEW STACK PNTR.
        JSR     CHRGOT
        CMP     #44             ;COMMA AT END?
        BNE     NEWSGO
        JSR     CHRGET
        JSR     GETFOR          ;DO NEXT BUT DON'T ALLOW BLANK VARIABLE
                                ;PNTR. [VARPNT] IS THE STK PNTR WHICH
                                ;NEVER MATCHES ANY POINTER.
                                ;JSR TO PUT ON DUMMY NEWSTT ADDR.
; SUBTTL FORMULA EVALUATION CODE.
;
; THESE ROUTINES CHECK FOR CERTAIN "VALTYP".
; [C] IS NOT PRESERVED.
;
FRMNUM: JSR     FRMEVL
CHKNUM: CLC
        SKIP1
CHKSTR: SEC                     ;SET CARRY.
CHKVAL: BIT     VALTYP          ;WILL NOT F UP "VALTYP".
        BMI     DOCSTR
        BCS     CHKERR
CHKOK:  RTS
DOCSTR: BCS     CHKOK
CHKERR: LDX     #ERRTM
ERRGO4: JMP     ERROR
;
; THE FORMULA EVALUATOR STARTS WITH
; [TXTPTR] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
; AT THE END [TXTPTR] POINTS TO THE TERMINATOR.
; THE RESULT IS LEFT IN THE FAC.
; ON RETURN [A] DOES NOT REFLECT THE TERMINATOR.
;
; THE FORMULA EVALUATOR USES THE OPERATOR LIST (OPTAB)
; TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR 
; EACH OPERATOR.
; A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT.
;       THE ADDRESS OF THE OPERATOR ROUTINE.
;       THE FLOATING POINT TEMPORARY RESULT.
;       THE PRECEDENCE OF THE OPERATOR.
;
FRMEVL: LDX     TXTPTR
        BNE     FRMEV1
        DEC     TXTPTR+1
FRMEV1: DEC     TXTPTR
        LDX     #0              ;INITIAL DUMMY PRECEDENCE IS 0.
        SKIP1
LPOPER: PHA                     ;SAVE LOW PRECEDENCE. (MASK.)
        TXA
        PHA                     ;SAVE HIGH PRECEDENCE.
        LDA     #1
        JSR     GETSTK          ;MAKE SURE THERE IS ROOM FOR
                                ;RECURSIVE CALLS.
        JSR     EVAL            ;EVALUATE SOMETHING.
        CLR     OPMASK          ;PREPARE TO BUILD MASK MAYBE.
TSTOP:  JSR     CHRGOT          ;REGET LAST CHARACTER.
LOPREL: SEC                     ;PREP TO SUBTRACT.
        SBC     #GREATK         ;IS CURRENT CHARACTER A RELATION?
        BCC     ENDREL          ;NO. RELATIONS ALL THROUGH.
        CMP     #LESSTK-GREATK+1 ;REALLY RELATIONAL?
        BCS     ENDREL          ;NO -- JUST BIG.
        CMP     #1              ;RESET CARRY FOR ZERO ONLY.
        ROL     A               ;0 TO 1, 1 TO 2, 2 TO 4.
        EOR     #1
        EOR     OPMASK          ;BRING IN THE OLD BITS.
        CMP     OPMASK          ;MAKE SURE THE NEW MASK IS BIGGER.
        BCC     SNERR5          ;SYNTAX ERROR. BECAUSE TWO OF THE SAME.
        STA     OPMASK          ;SAVE MASK.
        JSR     CHRGET
        JMP     LOPREL          ;GET THE NEXT CANDIDATE.
ENDREL: LDX     OPMASK          ;WERE THERE ANY?
        BNE     FINREL          ;YES, HANDLE AS SPECIAL OP.
        BCS     QOP             ;NOT AN OPERATOR.
        ADC     #GREATK-PLUSTK
        BCC     QOP             ;NOT AN OPERATOR.
        ADC     VALTYP          ;[C]=1.
        JEQ     CAT             ;ONLY IF [A]=0 AND [VALTYP]=-1 (A STR).
        ADC     #$FF            ;GET BACK ORIGINAL [A].
        STA     INDEX1
        ASL     A               ;MULTIPLY BY 2.
        ADC     INDEX1          ;BY THREE.
        TAY                     ;SET UP FOR LATER.
QPREC:  PLA                     ;GET PREVIOUS PRECEDENCE.
        CMP     OPTAB,Y         ;IS OLD PRECEDENCE GREATER OR EQUAL?
        BCS     QCHNUM          ;YES, GO OPERATE.
        JSR     CHKNUM          ;CAN'T BE STRING HERE.
DOPREC: PHA                     ;SAVE OLD PRECEDENCE.
NEGPRC: JSR     DOPRE1          ;SET A RETURN ADDRESS FOR OP.
        PLA                     ;PULL OFF PREVIOUS PRECEDENCE.
        LDY     OPPTR           ;GET POINTER TO OP.
        BPL     QPREC1          ;THAT'S A REAL OPERATOR.
        TAX                     ;DONE ?
        BEQ     QOPGO           ;DONE !
        BNE     PULSTK
FINREL: LSR     VALTYP          ;GET VALUE TYPE INTO "C".
        TXA
        ROL     A               ;PUT VALTYP INTO LOW ORDER BIT OF MASK.
        LDX     TXTPTR          ;DECREMENT TEXT POINTER.
        BNE     FINRE2
        DEC     TXTPTR+1
FINRE2: DEC     TXTPTR
        LDY     #PTDORL-OPTAB   ;MAKE [YREG] POINT AT OPERATOR ENTRY.
        STA     OPMASK          ;SAVE THE OPERATION MASK.
        BNE     QPREC           ;SAVE IT ALL. BR ALWAYS.
                                ;NOTE B7(VALTYP)=0 SO CHKNUM CALL IS OK.
QPREC1: CMP     OPTAB,Y         ;LAST PRECEDENCE IS GREATER?
        BCS     PULSTK          ;YES, GO OPERATE.
        BCC     DOPREC          ;NO SAVE ARGUMENT AND GET OTHER OPERAND.
DOPRE1: LDA     OPTAB+2,Y
        PHA                     ;DISP ADDR GOES ONTO STACK.
        LDA     OPTAB+1,Y
        PHA
        JSR     PUSHF1          ;SAVE FAC ON STACK UNPACKED.
        LDA     OPMASK          ;[ACCA] MAY BE MASK FOR REL.
        JMP     LPOPER
SNERR5: JMP     SNERR           ;GO TO AN ERROR.
PUSHF1: LDA     FACSGN
        LDX     OPTAB,Y ;GET HIGH PRECEDENCE.
PUSHF:  TAY                     ;GET POINTER INTO STACK.
        PLA
        STA     INDEX1
        INC     INDEX1
        PLA
        STA     INDEX1+1
        TYA
                                ;STORE FAC ON STACK UNPACKED.
        PHA                     ;START WITH SIGN SET UP.
FORPSH: JSR     ROUND           ;PUT ROUNDED FAC ON STACK.
        LDA     FACLO           ;ENTRY POINT TO SKIP STORING SIGN.
        PHA
        LDA     FACMO
        PHA
        LDA     FACMOH
        PHA
        LDA     FACHO
        PHA
        LDA     FACEXP
        PHA
        JMP     (INDEX1)                ;RETURN.
QOP:    LDY     #255
        PLA                     ;GET HIGH PRECEDENCE OF LAST OP.
QOPGO:  BEQ     QOPRTS          ;DONE !
QCHNUM: CMP     #100            ;RELATIONAL OPERATOR?
        BEQ     UNPSTK          ;YES, DON'T CHECK OPERAND.
        JSR     CHKNUM          ;MUST BE NUMBER.
UNPSTK: STY     OPPTR           ;SAVE OPERATOR'S POINTER FOR NEXT TIME.
PULSTK: PLA                     ;GET MASK FOR REL OP IF IT IS ONE.
        LSR     A               ;SETUP [C] FOR DOREL'S "CHKVAL".
        STA     DOMASK          ;SAVE FOR "DOCMP".
        PLA                     ;UNPACK STACK INTO ARG.
        STA     ARGEXP
        PLA
        STA     ARGHO
        PLA
        STA     ARGMOH
        PLA
        STA     ARGMO
        PLA
        STA     ARGLO
        PLA
        STA     ARGSGN
        EOR     FACSGN          ;GET PROBABLE RESULT SIGN.
        STA     ARISGN          ;ARITHMETIC SIGN. USED BY
                                ;ADD, SUB, MULT, DIV.
QOPRTS: LDA     FACEXP          ;GET IT AND SET CODES.
UNPRTS: RTS                     ;RETURN.

EVAL:   CLR     VALTYP          ;ASSUME VALUE WILL BE NUMERIC.
EVAL0:  JSR     CHRGET          ;GET A CHARACTER.
        BCS     EVAL2
EVAL1:  JMP     FIN             ;IT IS A NUMBER.
EVAL2:  JSR     ISLETC          ;VARIABLE NAME?
        BCS     ISVAR           ;YES.
        CMP     #PI
        BNE     QDOT
        LDWDI   PIVAL
        JSR     MOVFM           ;PUT VALUE IN FOR PI.
        JMP     CHRGET
PIVAL:  .BYTE 130
        .BYTE 73
        .BYTE 15
        .BYTE 218
        .BYTE 161
QDOT:   CMP     #'.'            ;LEADING CHARACTER OF CONSTANT?
        BEQ     EVAL1
        CMP     #MINUTK         ;NEGATION?
        BEQ     DOMIN           ;SHO IS.
        CMP     #PLUSTK
        BEQ     EVAL0
        CMP     #34             ;A QUOTE? A STRING?
        BNE     EVAL3
STRTXT: LDWD    TXTPTR
        ADC     #0              ;TO INC, ADD C=1.
        BCC     STRTX2
        INY
STRTX2: JSR     STRLIT          ;YES. GO PROCESS IT.
        JMP     ST2TXT
EVAL3:  CMP     #NOTTK          ;CHECK FOR "NOT" OPERATOR.
        BNE     EVAL4
        LDY     #NOTTAB-OPTAB           ;"NOT" HAS PRECEDENCE 90.
        BNE     GONPRC          ;GO DO ITS EVALUATION.
NOTOP:  JSR     AYINT           ;INTEGERIZE.
        LDA     FACLO           ;GET THE ARGUMENT.
        EOR     #255
        TAY
        LDA     FACMO
        EOR     #255
        JMP     GIVAYF          ;FLOAT [Y,A] AS RESULT IN FAC.
                                ;AND RETURN.
EVAL4:  CMP     #FNTK           ;USER-DEFINED FUNCTION?
        JEQ     FNDOER
        CMP     #ONEFUN         ;A FUNCTION NAME?
        BCC     PARCHK          ;FUNCTIONS ARE THE HIGHEST NUMBERED
        JMP     ISFUN           ;CHARACTERS SO NO NEED TO CHECK
                                ;AN UPPER-BOUND.
PARCHK: JSR     CHKOPN          ;ONLY POSSIBILITY LEFT IS
        JSR     FRMEVL          ;A FORMULA IN PARENTHESIS.
                                ;RECURSIVELY EVALUATE THE FORMULA.
CHKCLS: LDA     #41             ;CHECK FOR A RIGHT PARENTHESE
        SKIP2
CHKOPN: LDA     #40
        SKIP2
CHKCOM: LDA     #44
;
; "SYNCHK" LOOKS AT THE CURRENT CHARACTER TO MAKE SURE IT
; IS THE SPECIFIC THING LOADED INTO ACCA JUST BEFORE THE CALL TO
; "SYNCHK". IF NOT, IT CALLS THE "SYNTAX ERROR" ROUTINE.
; OTHERWISE IT GOBBLES THE NEXT CHAR AND RETURNS,
;
; [A]=NEW CHAR AND TXTPTR IS ADVANCED BY "CHRGET".
;
SYNCHR: LDY     #0
        CMP     (TXTPTR),Y              ;CHARACTERS EQUAL?
        BNE     SNERR
CHRGO5: JMP     CHRGET
SNERR:  LDX     #ERRSN          ;"SYNTAX ERROR"
        JMP     ERROR
DOMIN:  LDY     #NEGTAB-OPTAB   ;A PRECEDENCE BELOW "^".
GONPRC: PLA                     ;GET RID OF RTS ADDR.
        PLA
        JMP     NEGPRC          ;EVALUTE FOR NEGATION.

ISVAR:  JSR     PTRGET          ;GET A PNTR TO VARIABLE.
ISVRET: STWD    FACMO
        LDWD    VARNAM          ;CHECK TIME,TIME$,STATUS.
        LDX     VALTYP
        BEQ     GOOO            ;THE STRING IS SET UP.
        LDX     #0
        STX     FACOV
        BIT     FACLO           ;AN ARRAY?
        BPL     STRRTS          ;YES.
        CMP     #'T'            ;TI$?
        BNE     STRRTS
        CPY     #'I'+128
        BNE     STRRTS
        JSR     GETTIM          ;YES. PUT TIME IN FACMOH-LO.
        STY     TENEXP          ;Y=0.
        DEY
        STY     FBUFPT
        LDY     #6              ;SIX    DIGITS TO PRINT.
        STY     DECCNT
        LDY     #FDCEND-FOUTBL
        JSR     FOUTIM          ;CONVERT TO ASCII.
        JMP     TIMSTR
STRRTS: RTS
GOOO:
        LDX     INTFLG
        BPL     GOOOOO
        LDY     #0
        LDA     (FACMO),Y               ;FETCH HIGH.
        TAX
        INY
        LDA     (FACMO),Y
        TAY                     ;PUT LOW IN Y.
        TXA                     ;GET HIGH IN A.
        JMP     GIVAYF          ;FLOAT AND RETURN.
GOOOOO:
        BIT     FACLO           ;AN ARRAY?
        BPL     GOMOVF          ;YES.
        CMP     #'T'
        BNE     QSTATV
        CPY     #'I'
        BNE     GOMOVF
        JSR     GETTIM
        TYA                     ;FOR FLOATB.
        LDX     #160            ;SET EXPONNENT.
        JMP     FLOATB
GETTIM: LDWDI   (CQTIMR-2)
        SEI                     ;TURN OF INT SYS.
        JSR     MOVFM
        CLI                     ;BACK ON.
        STY     FACHO           ;ZERO HIGHEST.
        RTS
QSTATV:
        CMP     #'S'
        BNE     GOMOVF
        CPY     #'T'
        BNE     GOMOVF
        LDA     CQSTAT
        JMP     FLOAT
GOMOVF:
        LDWD    FACMO
        JMP     MOVFM           ;MOVE ACTUAL VALUE IN.
                                ;AND RETURN.

ISFUN:  ASL     A               ;MULTIPLY BY TWO.
        PHA
        TAX
        JSR     CHRGET          ;SET UP FOR SYNCHK.
        CPX     #2*LASNUM-256+1 ;IS IT PAST "LASNUM"?
        BCC     OKNORM          ;NO, MUST BE NORMAL FUNCTION.
;
; MOST FUNCTIONS TAKE A SINGLE ARGUMENT.
; THE RETURN ADDRESS OF THESE FUNCTIONS IS "CHKNUM"
; WHICH ASCERTAINS THAT [VALTYP]=0  (NUMERIC).
; NORMAL FUNCTIONS THAT RETURN STRING RESULTS
; (E.G., CHR$) MUST POP OFF THAT RETURN ADDR AND
; RETURN DIRECTLY TO "FRMEVL".
;
; THE SO-CALLED "FUNNY" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT,
; THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH
; MUST BE A NUMBER BETWEEN 0 AND 255.
; THE CLOSED PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY
; TO "FRMEVL" WITH THE TEXT PNTR POINTING BEYOND THE ")".
; THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT
; IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE
; INTEGER ARGUMENT.
;
        JSR     CHKOPN          ;CHECK FOR AN OPEN PARENTHESE
        JSR     FRMEVL          ;EAT OPEN PAREN AND FIRST ARG.
        JSR     CHKCOM          ;TWO ARGS SO COMMA MUST DELIMIT.
        JSR     CHKSTR          ;MAKE SURE FIRST WAS STRING.
        PLA                     ;GET FUNCTION NUMBER.
        TAX
        PSHWD   FACMO           ;SAVE POINTER AT STRING DESCRIPTOR
        TXA
        PHA                     ;RESAVE FUNCTION NUMBER.
                                ;THIS MUST BE ON STACK SINCE RECURSIVE.
        JSR     GETBYT          ;[X]=VALUE OF FORMULA.
        PLA                     ;GET FUNCTION NUMBER.
        TAY
        TXA
        PHA
        JMP     FINGO           ;DISPATCH TO FUNCTION.
OKNORM: JSR     PARCHK          ;READ A FORMULA SURROUNDED BY PARENS.
        PLA                     ;GET DISPATCH FUNCTION.
        TAY
FINGO:  LDA     FUNDSP-2*ONEFUN+256,Y   ;MODIFY DISPATCH ADDRESS.
        STA     JMPER+1
        LDA     FUNDSP-2*ONEFUN+257,Y
        STA     JMPER+2
        JSR     JMPER           ;DISPATCH!
                                ;STRING FUNCTIONS REMOVE THIS RET ADDR.
        JMP     CHKNUM          ;CHECK IT FOR NUMERICNESS AND RETURN.

OROP:   LDY     #255            ;MUST ALWAYS COMPLEMENT..
        SKIP2
ANDOP:  LDY     #0
        STY     COUNT           ;OPERATOR.
        JSR     AYINT           ;[FACMO&LO]=INT VALUE AND CHECK SIZE.
        LDA     FACMO           ;USE DEMORGAN'S LAW ON HIGH
        EOR     COUNT
        STA     INTEGR
        LDA     FACLO           ;AND LOW.
        EOR     COUNT
        STA     INTEGR+1
        JSR     MOVFA
        JSR     AYINT           ;[FACMO&LO]=INT OF ARG.
        LDA     FACLO
        EOR     COUNT
        AND     INTEGR+1
        EOR     COUNT           ;FINISH OUT DEMORGAN.
        TAY                     ;SAVE HIGH.
        LDA     FACMO
        EOR     COUNT
        AND     INTEGR
        EOR     COUNT
        JMP     GIVAYF          ;FLOAT [A.Y] AND RET TO USER.

;
; TIME TO PERFORM A RELATIONAL OPERATOR.
; [DOMASK] CONTAINS THE BITS AS TO WHICH RELATIONAL
; OPERATOR IT WAS. CARRY BIT ON=STRING COMPARE.
;
DOREL:  JSR     CHKVAL          ;CHECK FOR MATCH.
        BCS     STRCMP          ;IT IS A STRING.
        LDA     ARGSGN          ;PACK ARG FOR FCOMP.
        ORA     #127
        AND     ARGHO
        STA     ARGHO
        LDWDI   ARGEXP
        JSR     FCOMP
        TAX
        JMP     QCOMP
STRCMP: CLR     VALTYP          ;RESULT WILL BE NUMERIC.
        DEC     OPMASK          ;TURN OFF VALTYP WHICH WAS STRING.
        JSR     FREFAC          ;FREE THE FACLO STRING.
        STA     DSCTMP          ;SAVE FOR LATER.
        STXY    DSCTMP+1
        LDWD    ARGMO           ;GET POINTER TO OTHER STRING.
        JSR     FRETMP          ;FREES FIRST DESC POINTER.
        STXY    ARGMO
        TAX                     ;COPY COUNT INTO X.
        SEC
        SBC     DSCTMP          ;WHICH IS GREATER. IF 0, ALL SET UP.
        BEQ     STASGN          ;JUST PUT SIGN OF DIFFERENCE AWAY.
        LDA     #1
        BCC     STASGN          ;SIGN IS POSITIVE.
        LDX     DSCTMP          ;LENGTH OF FAC IS SHORTER.
        LDA     #$FF            ;GET A MINUS 1 FOR NEGATIVES.
STASGN: STA     FACSGN          ;KEEP FOR LATER.
        LDY     #255            ;SET POINTER TO FIRST STRING. (ARG.)
        INX                     ;TO LOOP PROPERLY.
NXTCMP: INY
        DEX                     ;ANY CHARACTERS LEFT TO COMPARE?
        BNE     GETCMP          ;NOT DONE YET.
        LDX     FACSGN          ;USE SIGN OF LENGTH DIFFERENCE
                                ;SINCE ALL CHARACTERS ARE THE SAME.
QCOMP:  BMI     DOCMP           ;C IS ALWAYS SET THEN.
        CLC
        BCC     DOCMP           ;ALWAYS BRANCH.
GETCMP: LDA     (ARGMO),Y               ;GET NEXT CHAR TO COMPARE.
        CMP     (DSCTMP+1),Y    ;SAME?
        BEQ     NXTCMP          ;YEP. TRY FURTHER.
        LDX     #$FF            ;SET A POSITIVE DIFFERENCE.
        BCS     DOCMP           ;PUT STACK BACK TOGETHER.
        LDX     #1              ;SET A NEGATIVE DIFFERENCE.
DOCMP:  INX                     ;-1 TO 1, 0 TO 2, 1 TO 4.
        TXA
        ROL     A
        AND     DOMASK
        BEQ     GOFLOT
        LDA     #$FF            ;MAP 0 TO 0. ALL OTHERS TO -1.
GOFLOT: JMP     FLOAT           ;FLOAT THE ONE-BYTE RESULT INTO FAC.

; SUBTTL        DIMENSION AND VARIABLE SEARCHING.
;
; THE "DIM" CODE SETS [DIMFLG] AND THEN FALLS INTO THE VARIABLE SEARCH
; ROUTINE, WHICH LOOKS AT DIMFLG AT THREE DIFFERENT POINTS.
;       1) IF AN ENTRY IS FOUND, "DIMFLG" BEING ON INDICATES
;               A "DOUBLY" DIMENSIONED VARIABLE.
;       2) WHEN A NEW ENTRY IS BEING BUILT "DIMFLG" BEING ON
;               INDICTAES THE INDICES SHOULD BE USED FOR THE
;               SIZE OF EACH INDEX. OTHERWISE THE DEFAULT OF TEN
;               IS USED.
;       3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF "DIMFLG" IS OFF
;               WILL INDEXING BE DONE.
;
DIM3:   JSR     CHKCOM          ;MUST BE A COMMA
DIM:    TAX                     ;SET [ACCX] NONZERO.
                                ;[ACCA] MUST BE NONZERO TO WORK RIGHT.
DIM1:   JSR     PTRGT1
DIMCON: JSR     CHRGOT          ;GET LAST CHARACTER.
        BNE     DIM3
        RTS
;
; ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
; AND  PUT A POINTER TO ITS VALUE IN VARPNT. [TXTPTR]
; POINTS TO THE TERMINATING CHARCTER.. NOT THAT EVALUATING SUBSCRIPTS
; IN A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO "PTRGET" SO AT
; THAT POINT ALL VALUES MUST BE STORED ON THE STACK.
;
PTRGET: LDX     #0              ;MAKE [ACCX]=0.
        JSR     CHRGOT          ;RETRIEVE LAST CHARACTER.
PTRGT1: STX     DIMFLG          ;STORE FLAG AWAY.
PTRGT2: STA     VARNAM
        JSR     CHRGOT          ;GET CURRENT CHARACTER
                                ;MAYBE WITH FUNCTION BIT OFF.
        JSR     ISLETC          ;CHECK FOR LETTER.
        BCS     PTRGT3          ;MUST HAVE A LETTER.
INTERR: JMP     SNERR
PTRGT3: LDX     #0              ;ASSUME NO SECOND CHARACTER.
        STX     VALTYP          ;DEFAULT IS NUMERIC.
        STX     INTFLG          ;ASSUME FLOATING.
        JSR     CHRGET          ;GET FOLLOWING CHARACTER.
        BCC     ISSEC           ;CARRY RESET BY CHRGET IF NUMERIC.
        JSR     ISLETC          ;SET CARRY IF NOT ALPHABETIC.
        BCC     NOSEC           ;ALLOW ALPHABETICS.
ISSEC:  TAX                     ;IT IS A NUMBER -- SAVE IN ACCX.
EATEM:  JSR     CHRGET          ;LOOK AT NEXT CHARACTER.
        BCC     EATEM           ;SKIP NUMERICS.
        JSR     ISLETC
        BCS     EATEM           ;SKIP ALPHABETICS.
NOSEC:  CMP     #'$'            ;IS IT A STRING?
        BNE     NOTSTR          ;IF NOT, [VALTYP]=0.
        LDA     #$FF            ;SET [VALTYP]=255 (STRING !).
        STA     VALTYP
        BNEA    TURNON          ;ALWAYS GOES.
NOTSTR: CMP     #'%'            ;INTEGER VARIABLE?
        BNE     STRNAM          ;NO.
        LDA     SUBFLG
        BNE     INTERR
        LDA     #128
        STA     INTFLG          ;SET FLAG.
        ORA     VARNAM          ;TURN ON BOTH HIGH BITS.
        STA     VARNAM
TURNON: TXA
        ORA     #128            ;TURN ON MSB OF SECOND CHARACTER.
        TAX
        JSR     CHRGET          ;GET CHARACTER AFTER $.
STRNAM: STX     VARNAM+1        ;STORE AWAY SECOND CHARACTER.
        SEC
        ORA     SUBFLG          ;ADD FLAG WHETHER TO ALLOW ARRAYS.
        SBC     #40             ;(CHECK FOR "(") WON'T MATCH IF SUBFLG SET. 
        JEQ     ISARY           ;IT IS!
        CLR     SUBFLG          ;ALLOW SUBSCRIPTS AGAIN.
        LDA     VARTAB          ;PLACE TO START SEARCH.
        LDX     VARTAB+1
        LDY     #0
STXFND: STX     LOWTR+1
LOPFND: STA     LOWTR
        CPX     ARYTAB+1        ;AT END OF TABLE YET?
        BNE     LOPFN
        CMP     ARYTAB
        BEQ     NOTFNS          ;YES. WE COULDN'T FIND IT.
LOPFN:  LDA     VARNAM
        CMP     (LOWTR),Y               ;COMPARE HIGH ORDERS.
        BNE     NOTIT           ;NO COMPARISON.
        LDA     VARNAM+1
        INY
        CMP     (LOWTR),Y               ;AND THE LOW PART?
        BEQ     FINPTR          ;THAT'S IT ! THAT'S IT !
        DEY
NOTIT:  CLC
        LDA     LOWTR
        ADC     #6+ADDPRC       ;MAKES NO DIF AMONG TYPES.
        BCC     LOPFND
        INX
        BNEA    STXFND          ;ALWAYS BRANCHES.

;
; TEST FOR A LETTER.    / CARRY OFF= NOT A LETTER.
;                         CARRY ON= A LETTER.
;
ISLETC: CMP     #'A'
        BCC     ISLRTS          ;IF LESS THAN "A", RET.
        SBC     #'Z'+1
        SEC
        SBC     #256-'Z'-1      ;RESET CARRY IF [A] .GT. "Z".
ISLRTS: RTS                     ;RETURN TO CALLER.

NOTFNS: PLA                     ;CHECK WHO'S CALLING.
        PHA                     ;RESTORE IT.
        CMP     #ISVRET-1-(ISVRET-1)/256*256    ;IS EVAL CALLING?
        BNE     NOTEVL          ;NO, CARRY ON.
LDZR:   LDWDI   ZERO            ;SET UP PNTR TO SIMULATED ZERO.
        RTS                     ;FOR STRINGS OR NUMERIC.
                                ;AND FOR INTEGERS TOO.
NOTEVL:
        LDWD    VARNAM
        CMP     #'T'
        BNE     QSTAVR
        CPY     #'I'+128
        BEQ     LDZR
        CPY     #'I'
        BNE     QSTAVR
GOBADV: JMP     SNERR
QSTAVR:
        CMP     #'S'
        BNE     VAROK
        CPY     #'T'
        BEQ     GOBADV
VAROK:  LDWD    ARYTAB
        STWD    LOWTR           ;LOWEST THING TO MOVE.
        LDWD    STREND          ;GET HIGHEST ADDR TO MOVE.
        STWD    HIGHTR
        CLC
        ADC     #6+ADDPRC
        BCC     NOTEVE
        INY
NOTEVE: STWD    HIGHDS          ;PLACE TO STUFF IT.
        JSR     BLTU            ;MOVE IT ALL.
                                ;NOTE [Y,A] HAS [HIGHDS] FOR REASON.
        LDWD    HIGHDS          ;AND SET UP
        INY
        STWD    ARYTAB          ;NEW START OF ARRAY TABLE.
        LDY     #0              ;GET ADDR OF VARIABLE ENTRY.
        LDA     VARNAM
        STA     (LOWTR),Y
        INY
        LDA     VARNAM+1
        STA     (LOWTR),Y               ;STORE NAME OF VARIABLE.
        LDA     #0
        INY
        STA     (LOWTR),Y
        INY
        STA     (LOWTR),Y
        INY
        STA     (LOWTR),Y
        INY
        STA     (LOWTR),Y               ;FOURTH ZERO FOR DEF FUNC.
        INY
        STA     (LOWTR),Y
FINPTR: LDA     LOWTR
        CLC
        ADC     #2
        LDY     LOWTR+1
        BCC     FINNOW
        INY
FINNOW: STWD    VARPNT          ;THIS IS IT.
        RTS
; SUBTTL        MULTIPLE DIMENSION CODE.
FMAPTR: LDA     COUNT
        ASL     A
        ADC     #5              ;POINT TO ENTRIES. C CLR'D BY ASL.
        ADC     LOWTR
        LDY     LOWTR+1
        BCC     JSRGM
        INY
JSRGM:  STWD    ARYPNT
        RTS

N32768: .BYTE 144,128,0,0       ;-32768.

;
; INTIDX READS A FORMULA FROM THE CURRENT POSITION AND
; TURNS IT INTO A POSITIVE INTEGER
; LEAVING THE RESULT IN FACMO&LO. NEGATIVE ARGUMENTS
; ARE NOT ALLOWED.
;
INTIDX: JSR     CHRGET
        JSR     FRMEVL          ;GET A NUMBER
POSINT: JSR     CHKNUM
        LDA     FACSGN
        BMI     NONONO          ;IF NEGATIVE, BLOW HIM OUT.
AYINT:  LDA     FACEXP
        CMP     #144            ;FAC .GT. 32767?
        BCC     QINTGO
        LDWDI   N32768          ;GET ADDR OF -32768.
        JSR     FCOMP           ;SEE IF FAC=[[Y,A]].
NONONO: BNE     FCERR           ;NO, FAC IS TOO BIG.
QINTGO: JMP     QINT            ;GO TO QINT AND SHOVE IT.
;
; FORMAT OF ARRAYS IN CORE.
;
; DESCRIPTOR:
;       LOWBYTE = FIRST CHARACTER.
;       HIGHBYTE = SECOND CHARACTER (200 BIT IS STRING FLAG).
; LENGTH OF ARRAY IN CORE IN BYTES (INCLUDES EVERYTHING).
; NUMBER OF DIMENSIONS.
; FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
; (2 BYTES EACH) OF THE MAX INDICE+1
; THE VALUES
;
ISARY:  LDA     DIMFLG
        ORA     INTFLG
        PHA                     ;SAVE [DIMFLG] FOR RECURSION.
        LDA     VALTYP
        PHA                     ;SAVE [VALTYP] FOR RECURSION.
        LDY     #0              ;SET NUMBER OF DIMENSIONS TO ZERO.
INDLOP: TYA                     ;SAVE NUMBER OF DIMS.
        PHA
        PSHWD   VARNAM          ;SAVE LOOKS.
        JSR     INTIDX          ;EVALUATE INDICE INTO FACMO&LO.
        PULWD   VARNAM          ;GET BACK ALL... WE'RE HOME.
        PLA                     ;(# OF DIMS).
        TAY
        TSX
        LDA     258,X
        PHA                     ;PUSH DIMFLG AND VALTYP FURTHER.
        LDA     257,X
        PHA
        LDA     INDICE          ;PUT INDICE ONTO STACK.
        STA     258,X           ;UNDER DIMFLG AND VALTYP.
        LDA     INDICE+1
        STA     257,X
        INY                     ;INCREMENT # OF DIMS.
        JSR     CHRGOT          ;GET TERMINATING CHARACTER.
        CMP     #44             ;A COMMA?
        BEQ     INDLOP          ;YES.
        STY     COUNT           ;SAVE COUNT OF DIMS.
        JSR     CHKCLS          ;MUST BE CLOSED PAREN.
        PLA
        STA     VALTYP          ;GET VALTYP AND
        PLA
        STA     INTFLG
        AND     #127
        STA     DIMFLG          ;DIMFLG OFF STACK.
        LDX     ARYTAB          ;PLACE TO START SEARCH.
        LDA     ARYTAB+1
LOPFDA: STX     LOWTR
        STA     LOWTR+1
        CMP     STREND+1        ;END OF ARRAYS?
        BNE     LOPFDV
        CPX     STREND
        BEQ     NOTFDD          ;A FINE THING! NO ARRAY!.
LOPFDV: LDY     #0
        LDA     (LOWTR),Y
        INY
        CMP     VARNAM          ;COMPARE HIGH ORDERS.
        BNE     NMARY1          ;NO WAY IS IT THIS. GET OUT OF HERE.
        LDA     VARNAM+1
        CMP     (LOWTR),Y               ;LOW ORDERS?
        BEQ     GOTARY          ;WELL, HERE IT IS !!
NMARY1: INY
        LDA     (LOWTR),Y               ;GET LENGTH.
        CLC
        ADC     LOWTR
        TAX
        INY
        LDA     (LOWTR),Y
        ADC     LOWTR+1
        BCC     LOPFDA          ;ALWAYS BRANCHES.
BSERR:  LDX     #ERRBS          ;GET BAD SUB ERROR NUMBER.
        SKIP2
FCERR:  LDX     #ERRFC          ;TOO BIG. "FUNCTION CALL" ERROR.
ERRGO3: JMP     ERROR
GOTARY: LDX     #ERRDD          ;PERHAPS A "RE-DIMENSION" ERROR
        LDA     DIMFLG          ;TEST THE DIMFLG
        BNE     ERRGO3
        JSR     FMAPTR
        LDA     COUNT           ;GET NUMBER OF DIMS INPUT.
        LDY     #4
        CMP     (LOWTR),Y               ;# OF DIMS THE SAME?
        BNE     BSERR           ;SAME SO GO GET DEFINITION.
        JMP     GETDEF

;
; HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE.
;
; BUILDING AN ENTRY.
;
;       PUT DOWN THE DESCRIPTOR.
;       SETUP NUMBER OF DIMENSIONS.
;       MAKE SURE THERE IS ROOM FOR THE NEW ENTRY.
;       REMEMBER "VARPNT".
;       TALLY=4.
;       SKIP 2 LOCS FOR LATER FILL IN OF SIZE.
; LOOP: GET AN INDICE
;       PUT DOWN NUMBER+1 AND INCREMENT VARPTR.
;       TALLY=TALLY*NUMBER+1.
;       DECREMENT NUMBER-DIMS.
;       BNE LOOP
;       CALL "REASON" WITH [Y,A] REFLECTING LAST LOC OF VARIABLE.
;       UPDATE STREND.
;       ZERO ALL.
;       MAKE TALLY INCLUDE MAXDIMS AND DESCRIPTOR.
;       PUT DOWN TALLY.
;       IF CALLED BY DIMENSION, RETURN.
;       OTHERWISE INDEX INTO THE VARIABLE AS IF IT
;        WERE FOUND ON THE INITIAL SEARCH.
;
NOTFDD: JSR     FMAPTR          ;FORM ARYPNT.
        JSR     REASON
        LDA     #0
        TAY
        STA     CURTOL+1
        LDX     #5
        LDA     VARNAM          ;THIS CODE ONLY WORKS FOR INTPRC=1
        STA     (LOWTR),Y               ;IF ADDPRC=1.
        BPL     NOTFLT
        DEX
NOTFLT: INY
        LDA     VARNAM+1
        STA     (LOWTR),Y
        BPL     STOMLT
        DEX
        DEX
STOMLT: STX     CURTOL
        LDA     COUNT
        INY
        INY
        INY
        STA     (LOWTR),Y               ;SAVE NUMBER OF DIMENSIONS.
LOPPTA: LDX     #11             ;DEFAULT SIZE.
        LDA     #0
        BIT     DIMFLG
        BVC     NOTDIM          ;NOT IN A DIM STATEMENT.
        PLA                     ;GET LOW ORDER OF INDICE.
        CLC
        ADC     #1
        TAX
        PLA                     ;GET HIGH PART OF INDICE.
        ADC     #0
NOTDIM: INY
        STA     (LOWTR),Y               ;STORE HIGH PART OF INDICE.
        INY
        TXA
        STA     (LOWTR),Y               ;STORE LOW ORDER OF INDICE.
        JSR     UMULT           ;[X,A]=[CURTOL]*[LOWTR,Y]
        STX     CURTOL          ;SAVE NEW TALLY.
        STA     CURTOL+1
        LDY     INDEX
        DEC     COUNT           ;ANY MORE INDICES LEFT?
        BNE     LOPPTA          ;YES.
        ADC     ARYPNT+1
        BCS     OMERR1          ;OVERFLOW.
        STA     ARYPNT+1        ;COMPUTE WHERE TO ZERO.
        TAY
        TXA
        ADC     ARYPNT
        BCC     GREASE
        INY
        BEQ     OMERR1
GREASE: JSR     REASON          ;GET ROOM.
        STWD    STREND          ;NEW END OF STORAGE.
        LDA     #0              ;STORING [ACCA] IS FASTER THAN CLEAR.
        INC     CURTOL+1
        LDY     CURTOL
        BEQ     DECCUR
ZERITA: DEY
        STA     (ARYPNT),Y
        BNE     ZERITA          ;NO. CONTINUE.
DECCUR: DEC     ARYPNT+1
        DEC     CURTOL+1
        BNE     ZERITA          ;DO ANOTHER BLOCK.
        INC     ARYPNT+1        ;BUMP BACK UP. WILL USE LATER.
        SEC
        LDA     STREND          ;RESTORE [ACCA].
        SBC     LOWTR           ;DETERMINE LENGTH.
        LDY     #2
        STA     (LOWTR),Y               ;LOW.
        LDA     STREND+1
        INY
        SBC     LOWTR+1
        STA     (LOWTR),Y               ;HIGH.
        LDA     DIMFLG
        BNE     DIMRTS          ;BYE.
        INY
;
; AT THIS POINT [LOWTR,Y] POINTS BEYOND THE SIZE TO THE NUMBER OF
; DIMENSIONS. STRATEGY:
;       NUMDIM=NUMBER OF DIMENSIONS.
;       CURTOL=0.
; INLPNM:GET A NEW INDICE.
;       MAKE SURE INDICE IS NOT TOO BIG.
;       MULTIPLY CURTOL BY CURMAX.
;       ADD INDICE TO CURTOL.
;       NUMDIM=NUMDIM-1.
;       BNE     INLPNM.
;       USE [CURTOL]*4 AS OFFSET.
;
GETDEF: LDA     (LOWTR),Y
        STA     COUNT           ;SAVE A COUNTER.
        LDA     #0              ;ZERO [CURTOL].
        STA     CURTOL
INLPNM: STA     CURTOL+1
        INY
        PLA                     ;GET LOW INDICE.
        TAX
        STA     INDICE
        PLA                     ;AND THE HIGH PART
        STA     INDICE+1
        CMP     (LOWTR),Y               ;COMPARE WITH MAX INDICE.
        BCC     INLPN2
        BNE     BSERR7          ;IF GREATER, "BAD SUBSCRIPT" ERROR.
        INY
        TXA
        CMP     (LOWTR),Y
        BCC     INLPN1
BSERR7: JMP     BSERR
OMERR1: JMP     OMERR
INLPN2: INY
INLPN1: LDA     CURTOL+1        ;DON'T MULTIPLY IF CURTOL=0.
        ORA     CURTOL
        CLC                     ;PREPARE TO GET INDICE BACK.
        BEQ     ADDIND          ;GET HIGH PART OF INDICE BACK.
        JSR     UMULT           ;MULTIPLY [CURTOL] BY [LOWTR,Y,Y+1].
        TXA
        ADC     INDICE          ;ADD IN [INDICE].
        TAX
        TYA
        LDY     INDEX1
ADDIND: ADC     INDICE+1
        STX     CURTOL
        DEC     COUNT           ;ANY MORE?
        BNE     INLPNM          ;YES.
        STA     CURTOL+1        ;FIX ARRAY BUG ****
        LDX     #5              ;THIS CODE ONLY WORKS FOR INTPRC=1
        LDA     VARNAM          ;IF ADDPRC=1.
        BPL     NOTFL1
        DEX
NOTFL1: LDA     VARNAM+1
        BPL     STOML1
        DEX
        DEX
STOML1: STX     ADDEND
        LDA     #0
        JSR     UMULTD          ;ON RTS, A&Y=HI . X=LO.
        TXA
        ADC     ARYPNT
        STA     VARPNT
        TYA
        ADC     ARYPNT+1
        STA     VARPNT+1
        TAY
        LDA     VARPNT
DIMRTS: RTS                     ;RETURN TO CALLER.
; SUBTTL        INTEGER ARITHMETIC ROUTINES.
        ;TWO BYTE UNSIGNED INTEGER MULTIPLY.
        ;THIS IS FOR MULTIPLY DIMENSIONED ARRAYS.
        ; [X,Y]=[X,A]=[CURTOL]*[LOWTR,Y,Y+1].
UMULT:  STY     INDEX
        LDA     (LOWTR),Y
        STA     ADDEND          ;LOW, THEN HIGH.
        DEY
        LDA     (LOWTR),Y               ;PUT [LOWTR,Y,Y+1] IN FASTER MEMORY.
UMULTD: STA     ADDEND+1
        LDA     #16
        STA     DECCNT
        LDX     #0              ;CLR THE ACCS.
        LDY     #0              ;RESULT INITIALLY ZERO.
UMULTC: TXA
        ASL     A               ;MULTIPLY BY TWO.
        TAX
        TYA
        ROL     A
        TAY
        BCS     OMERR1          ;TWO MUCH !
        ASL     CURTOL
        ROL     CURTOL+1
        BCC     UMLCNT          ;NOTHING IN THIS POSITION TO MULTIPLY.
        CLC
        TXA
        ADC     ADDEND
        TAX
        TYA
        ADC     ADDEND+1
        TAY
        BCS     OMERR1          ;MAN, JUST TOO MUCH !
UMLCNT: DEC     DECCNT          ;DONE?
        BNE     UMULTC          ;KEEP IT UP.
UMLRTS: RTS                     ;YES, ALL DONE.
; SUBTTL        FRE FUNCTION AND INTEGER TO FLOATING ROUTINES.
FRE:    LDA     VALTYP
        BEQ     NOFREF
        JSR     FREFAC
NOFREF: JSR     GARBA2
        SEC
        LDA     FRETOP          ;WE WANT
        SBC     STREND          ;[FRETOP]-[STREND].
        TAY
        LDA     FRETOP+1
        SBC     STREND+1

GIVAYF: LDX     #0
        STX     VALTYP
        STWD    FACHO
        LDX     #144            ;SET EXPONENT TO 2^16.
        JMP     FLOATS          ;TURN IT TO A FLOATING PNT #.

POS:    LDY     TRMPOS          ;GET POSITION.
SNGFLT: LDA     #0
        BEQA    GIVAYF          ;FLOAT IT.
; SUBTTL        SIMPLE-USER-DEFINED-FUNCTION CODE.
;
; NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
; AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
;       DEF FNA(X)=X^2+X-2
; NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS.
;
; IDEA: CREATE A SIMPLE VARIABLE ENTRY
; WHOSE FIRST CHARACTER HAS THE 200 BIT SET.
; THE VALUE WILL BE:
;
;       A TEXT PNTR TO THE FORMULA.
;       A PNTR TO THE ARGUMENT VARIABLE.
;
; FUNCTION NAMES CAN BE LIKE "FNA4".
;
;
; SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE.
; AND COMPLAIN IF SO.
;
ERRDIR: LDX     CURLIN+1        ;DIR MODE HAS [CURLIN]=0,255
        INX                     ;SO NOW, IS RESULT ZERO?
        BNE     DIMRTS          ;YES.
        LDX     #ERRID          ;INPUT DIRECT ERROR CODE.
        SKIP2
ERRGUF: LDX     #ERRUF          ;USER DEFINED FUNCTION NEVER DEFINED
ERRGO1: JMP     ERROR

DEF:    JSR     GETFNM          ;GET A PNTR TO THE FUNCTION.
        JSR     ERRDIR
        JSR     CHKOPN          ;MUST HAVE "(".
        LDA     #128
        STA     SUBFLG          ;PROHIBIT SUBSCRIPTED VARIABLES.
        JSR     PTRGET          ;GET PNTR TO ARGUMENT.
        JSR     CHKNUM          ;IS IT A NUMBER?
        JSR     CHKCLS          ;MUST HAVE ")"
        SYNCHK  EQULTK          ;MUST HAVE "=".
PHA             ;PUT CRAZY BYTE ON.
        PSHWD   VARPNT
        PSHWD   TXTPTR
        JSR     DATA
        JMP     DEFFIN
;
; SUBROUTINE TO GET A PNTR TO A FUNCTION NAME.
;
GETFNM: SYNCHK  FNTK            ;MUST START WITH FN.
        ORA     #128            ;PUT FUNCTION BIT ON.
        STA     SUBFLG
        JSR     PTRGT2          ;GET POINTER TO FUNCTION OR CREATE ANEW.
        STWD    DEFPNT
        JMP     CHKNUM          ;MAKE SURE IT'S NOT A STRING AND RETURN.

FNDOER: JSR     GETFNM          ;GET THE FUNCTION'S NAME.
        PSHWD   DEFPNT
        JSR     PARCHK          ;EVALUATE PARAMETER.
        JSR     CHKNUM
        PULWD   DEFPNT
        LDY     #2
        LDA     (DEFPNT),Y              ;GET POINTER TO VARIABLE.
        STA     VARPNT          ;SAVE VARIABLE POINTER.
        TAX
        INY
        LDA     (DEFPNT),Y
        BEQ     ERRGUF
        STA     VARPNT+1
INY             ;SINCE DEF USES ONLY 4.
DEFSTF: LDA     (VARPNT),Y
        PHA                     ;PUSH IT ALL ON STACK.
        DEY                     ;SINCE WE ARE RECURSING MAYBE.
        BPL     DEFSTF
        LDY     VARPNT+1
        JSR     MOVMF           ;PUT CURRENT FAC INTO OUR ARG VARIABLE.
        PSHWD   TXTPTR          ;SAVE TEXT POINTER.
        LDA     (DEFPNT),Y              ;PNTR TO FUNCTION.
        STA     TXTPTR
        INY
        LDA     (DEFPNT),Y
        STA     TXTPTR+1
        PSHWD   VARPNT          ;SAVE VARIABLE POINTER.
        JSR     FRMNUM          ;EVALUATE FORMULA AND CHECK NUMERIC.
        PULWD   DEFPNT
        JSR     CHRGOT
        JNE     SNERR           ;IT DIDN'T TERMINATE. HUH?
        PULWD   TXTPTR          ;RESTORE TEXT PNTR.
DEFFIN: LDY     #0
        PLA                     ;GET OLD ARG VALUE OFF STACK
        STA     (DEFPNT),Y              ;AND PUT IT BACK IN VARIABLE.
        PLA
        INY
        STA     (DEFPNT),Y
        PLA
        INY
        STA     (DEFPNT),Y
        PLA
        INY
        STA     (DEFPNT),Y
        PLA
        INY     
        STA     (DEFPNT),Y
DEFRTS: RTS
; SUBTTL        STRING FUNCTIONS.
;
; THE STR$ FUNCTION TAKES A NUMBER AND GIVES A STRING
; WITH THE CHARACTERS THE OUTPUT OF THE NUMBER
; WOULD HAVE GIVEN.
;
STR:    JSR     CHKNUM          ;ARG HAS TO BE NUMERIC.
        LDY     #0
        JSR     FOUTC           ;DO ITS OUTPUT.
        PLA
        PLA
TIMSTR: LDWDI   LOFBUF
        BEQA    STRLIT          ;SCAN IT AND TURN IT INTO A STRING.
;
; "STRINI" GET STRING SPACE FOR THE CREATION OF A STRING AND
; CREATES A DESCRIPTOR FOR IT IN "DSCTMP".
;
STRINI: LDXY    FACMO           ;GET FACMO TO STORE IN DSCPNT.
        STXY    DSCPNT          ;RETAIN THE DESCRIPTOR POINTER.
STRSPA: JSR     GETSPA          ;GET STRING SPACE.
        STXY    DSCTMP+1        ;SAVE LOCATION.
        STA     DSCTMP          ;SAVE LENGTH.
        RTS                     ;ALL DONE.
;
; "STRLT2" TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
; IS POINTED TO BY [Y,A] AND BUILDS A DESCRIPTOR FOR IT.
; THE DESCRIPTOR IS INITIALLY BUILT IN "DSCTMP", BUT "PUTNEW"
; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
; AT THE TEMPORARY IN FACMO&LO. THE CHARACTERS OTHER THAN
; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN "CHARAC"
; AND "ENDCHR". IF THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE JSR. ON RETURN
; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
; BY [STRNG2].
;
STRLIT: LDX     #34             ;ASSUME STRING ENDS ON QUOTE.
        STX     CHARAC
        STX     ENDCHR
STRLT2: STWD    STRNG1          ;SAVE POINTER TO STRING.
        STWD    DSCTMP+1        ;IN CASE NO STRCPY.
        LDY     #255            ;INITIALIZE CHARACTER COUNT.
STRGET: INY
        LDA     (STRNG1),Y              ;GET CHARACTER.
        BEQ     STRFI1          ;IF ZERO.
        CMP     CHARAC          ;THIS TERMINATOR?
        BEQ     STRFIN          ;YES.
        CMP     ENDCHR
        BNE     STRGET          ;LOOK FURTHER.
STRFIN: CMP     #34             ;QUOTE?
        BEQ     STRFI2
STRFI1: CLC                     ;NO, BACK UP.
STRFI2: STY     DSCTMP          ;RETAIN COUNT.
        TYA
        ADC     STRNG1          ;WISHING TO SET [TXTPTR].
        STA     STRNG2
        LDX     STRNG1+1
        BCC     STRST2
        INX
STRST2: STX     STRNG2+1
        LDA     STRNG1+1        ;IF PAGE 0, COPY SINCE IT IS EITHER
                                ;A STRING CONSTANT IN BUF OR A STR$
                                ;RESULT IN LOFBUF
        BEQ     STRCP
        CMP     #BUFPAG
        BNE     PUTNEW
STRCP:  TYA
        JSR     STRINI
        LDXY    STRNG1
        JSR     MOVSTR          ;MOVE STRING.
;
; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP.
; SETUP A TEMP DESCRIPTOR WITH DSCTMP IN IT.
; PUT A POINTER TO THE DESCRIPTOR IN FACMO&LO AND FLAG THE
; RESULT AS TYPE STRING.
;
PUTNEW: LDX     TEMPPT          ;POINTER TO FIRST FREE TEMP.
        CPX     #TEMPST+STRSIZ*NUMTMP
        BNE     PUTNW1
        LDX     #ERRST          ;STRING TEMPORARY ERROR.
ERRGO2: JMP     ERROR           ;GO TELL HIM.
PUTNW1: LDA     DSCTMP
        STA     0,X
        LDA     DSCTMP+1
        STA     1,X
        LDA     DSCTMP+2
        STA     2,X
        LDY     #0
        STXY    FACMO
        STY     FACOV
        DEY
        STY     VALTYP          ;TYPE IS "STRING".
        STX     LASTPT          ;SET POINTER TO LAST-USED TEMP.
        INX
        INX
        INX                     ;POINT FURTHER.
        STX     TEMPPT          ;SAVE POINTER TO NEXT TEMP IF ANY.
        RTS                     ;ALL DONE.

;
; GETSPA - GET SPACE FOR CHARACTER STRING.
; MAY FORCE GARBAGE COLLECTION.
;
; # OF CHARACTERS (BYTES) IN ACCA.
; RETURNS WITH POINTER IN [Y,X]. OTHERWISE (IF CAN'T GET
; SPACE) BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
; ALSO PRESERVES [ACCA] AND SETS [FRESPC]=[Y,X]=PNTR AT SPACE.
;
GETSPA: LSR     GARBFL          ;SIGNAL NO GARBAGE COLLECTION YET.
TRYAG2: PHA                     ;SAVE FOR LATER.
        EOR     #255
        SEC                     ;ADD ONE TO COMPLETE NEGATION.
        ADC     FRETOP
        LDY     FRETOP+1
        BCS     TRYAG3
        DEY
TRYAG3: CPY     STREND+1        ;COMPARE HIGH ORDERS.
        BCC     GARBAG          ;MAKE ROOM FOR MORE.
        BNE     STRFRE          ;SAVE NEW FRETOP.
        CMP     STREND          ;COMPARE LOW ORDERS.
        BCC     GARBAG          ;CLEAN UP.
STRFRE: STWD    FRETOP          ;SAVE NEW [FRETOP].
        STWD    FRESPC          ;PUT IT THERE OLD MAN.
        TAX                     ;PRESERVE A IN X.
        PLA                     ;GET COUNT BACK IN ACCA.
        RTS                     ;ALL DONE.
GARBAG: LDX     #ERROM          ;"OUT OF STRING SPACE"
        LDA     GARBFL
        BMI     ERRGO2
        JSR     GARBA2
        LDA     #128
        STA     GARBFL
        PLA                     ;GET BACK STRING LENGTH.
        BNE     TRYAG2          ;ALWAYS BRANCHES.
GARBA2:                         ;START FROM TOP DOWN.
        LDX     MEMSIZ
        LDA     MEMSIZ+1
FNDVAR: STX     FRETOP          ;LIKE SO.
        STA     FRETOP+1
        LDY     #0
        STY     GRBPNT+1
        STY     GRBPNT          ;BOTH BYTES SET TO ZERO (FIX BUG)
        LDWX    STREND
        STWX    GRBTOP
        LDWXI   TEMPST
        STWX    INDEX1
TVAR:   CMP     TEMPPT          ;DONE WITH TEMPS?
        BEQ     SVARS           ;YEP.
        JSR     DVAR
        BEQ     TVAR            ;LOOP.
SVARS:  LDA     #6+ADDPRC
        STA     FOUR6
        LDWX    VARTAB          ;GET START OF SIMPLE VARIABLES.
        STWX    INDEX1
SVAR:   CPX     ARYTAB+1        ;DONE WITH SIMPLE VARIABLES?
        BNE     SVARGO          ;NO.
        CMP     ARYTAB
        BEQ     ARYVAR          ;YEP.
SVARGO: JSR     DVARS           ;DO IT , AGAIN.
        BEQ     SVAR            ;LOOP.
ARYVAR: STWX    ARYPNT          ;SAVE FOR ADDITION.
        LDA     #STRSIZ
        STA     FOUR6
ARYVA2: LDWX    ARYPNT          ;GET THE POINTER TO VARIABLE.
ARYVA3: CPX     STREND+1        ;DONE WITH ARRAYS?
        BNE     ARYVGO          ;NO.
        CMP     STREND
        JEQ     GRBPAS          ;YES, GO FINISH UP.
ARYVGO: STWX    INDEX1
        LDY     #1-ADDPRC
        LDA     (INDEX1),Y
        TAX
        INY
        LDA     (INDEX1),Y
        PHP
        INY
        LDA     (INDEX1),Y
        ADC     ARYPNT
        STA     ARYPNT          ;FORM POINTER TO NEXT ARRAY VAR.
        INY
        LDA     (INDEX1),Y
        ADC     ARYPNT+1
        STA     ARYPNT+1
        PLP
        BPL     ARYVA2
        TXA
        BMI     ARYVA2
        INY
        LDA     (INDEX1),Y
        LDY     #0              ;RESET INDEX Y.
        ASL     A
        ADC     #5              ;CARRY IS OFF AND OFF AFTER ADD.
        ADC     INDEX1
        STA     INDEX1
        BCC     ARYGET
        INC     INDEX1+1
ARYGET: LDX     INDEX1+1
ARYSTR: CPX     ARYPNT+1        ;END OF THE ARRAY?
        BNE     GOGO
        CMP     ARYPNT
        BEQ     ARYVA3          ;YES.
GOGO:   JSR     DVAR
        BEQ     ARYSTR          ;CYCLE.
DVARS:
        LDA     (INDEX1),Y
        BMI     DVARTS
        INY
        LDA     (INDEX1),Y
        BPL     DVARTS
        INY
DVAR:   LDA     (INDEX1),Y              ;IS LENGTH=0?
        BEQ     DVARTS          ;YES, RETURN.
        INY
        LDA     (INDEX1),Y              ;GET LOW(ADR).
        TAX
        INY
        LDA     (INDEX1),Y
        CMP     FRETOP+1        ;COMPARE HIGHS.
        BCC     DVAR2           ;IF THIS STRING'S PNTR .GE. [FRETOP]
        BNE     DVARTS          ;NO NEED TO MESS WITH IT FURTHER.
        CPX     FRETOP          ;COMPARE LOWS.
        BCS     DVARTS
DVAR2:  CMP     GRBTOP+1
        BCC     DVARTS          ;IF THIS STRING IS BELOW PREVIOUS,
                                ;FORGET IT.
        BNE     DVAR3
        CPX     GRBTOP          ;COMPARE LOW ORDERS.
        BCC     DVARTS          ;[X,A] .LE. [GRBTOP].
DVAR3:  STX     GRBTOP
        STA     GRBTOP+1
        LDWX    INDEX1
        STWX    GRBPNT
        LDA     FOUR6
        STA     SIZE
DVARTS: LDA     FOUR6
        CLC
        ADC     INDEX1
        STA     INDEX1
        BCC     GRBRTS
        INC     INDEX1+1
GRBRTS: LDX     INDEX1+1
        LDY     #0
        RTS                     ;DONE.
;
; HERE WHEN MADE ONE COMPLETE PASS THROUGH STRING VARIABLES.
;
GRBPAS: LDA     GRBPNT+1        ;VARIABLE POINTER.
        ORA     GRBPNT
        BEQ     GRBRTS          ;ALL DONE.
        LDA     SIZE
        AND     #4              ;LEAVES C OFF.
        LSR     A
        TAY
        STA     SIZE
        LDA     (GRBPNT),Y
                                ;NOTE: GRBTOP=LOWTR SO NO NEED TO SET LOWTR.
        ADC     LOWTR
        STA     HIGHTR
        LDA     LOWTR+1
        ADC     #0
        STA     HIGHTR+1
        LDWX    FRETOP
        STWX    HIGHDS          ;WHERE IT ALL GOES.
        JSR     BLTUC
        LDY     SIZE
        INY
        LDA     HIGHDS          ;GET POSITION OF START OF RESULT.
        STA     (GRBPNT),Y
        TAX
        INC     HIGHDS+1
        LDA     HIGHDS+1
        INY
        STA     (GRBPNT),Y              ;CHANGE ADDR OF STRING IN VAR.
        JMP     FNDVAR          ;GO TO FNDVAR WITH SOMETHING FOR
                                ;[FRETOP].
;
; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS.
; THE FAC CONTAINS THE FIRST ONE AT THIS POINT.
; [TXTPTR] POINTS TO THE + SIGN.
;
CAT:    LDA     FACLO           ;PSH HIGH ORDER ONTO STACK.
        PHA
        LDA     FACMO           ;AND THE LOW.
        PHA
        JSR     EVAL            ;CAN COME BACK HERE SINCE
                                ;OPERATOR IS KNOWN.
        JSR     CHKSTR          ;RESULT MUST BE STRING.
        PLA
        STA     STRNG1          ;GET HIGH ORDER OF OLD DESC.
        PLA
        STA     STRNG1+1
        LDY     #0
        LDA     (STRNG1),Y              ;GET LENGTH OF OLD STRING.
        CLC
        ADC     (FACMO),Y
        BCC     SIZEOK          ;RESULT IS LESS THAN 256.
        LDX     #ERRLS          ;ERROR "LONG STRING".
        JMP     ERROR
SIZEOK: JSR     STRINI          ;INITIALIZE STRING.
        JSR     MOVINS          ;MOVE IT.
        LDWD    DSCPNT          ;GET POINTER TO SECOND.
        JSR     FRETMP          ;FREE IT.
        JSR     MOVDO
        LDWD    STRNG1
        JSR     FRETMP
        JSR     PUTNEW
        JMP     TSTOP           ;"CAT" REENTERS FORM EVAL AT TSTOP.

MOVINS: LDY     #0              ;GET ADDR OF STRING.
        LDA     (STRNG1),Y
        PHA
        INY
        LDA     (STRNG1),Y
        TAX
        INY
        LDA     (STRNG1),Y
        TAY
        PLA
MOVSTR: STXY    INDEX
MOVDO:  TAY
        BEQ     MVDONE
        PHA
MOVLP:  DEY
        LDA     (INDEX),Y
        STA     (FRESPC),Y
QMOVE:  TYA
        BNE     MOVLP
        PLA
MVDONE: CLC
        ADC     FRESPC
        STA     FRESPC
        BCC     MVSTRT
        INC     FRESPC+1
MVSTRT: RTS
;
; "FRETMP" IS PASSED A STRING DESCRIPTOR PNTR IN [Y,A].
; A CHECK IS MADE TO SEE IF THE STRING DESCRIPTOR POINTS TO THE LAST
; TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF [TEMPPT].
; IF A TEMP IS FREED UP, A FURTHER CHECK SEES IF THE STRING DATA THAT
; THAT STRING TEMP PNT'D TO IS THE LOWEST PART OF STRING SPACE IN USE.
; IF SO, [FRETOP] IS UPDATED TO REFLECT THE FACT THE FACT THAT THE SPACE
; IS NO LONGER IN USE.
; THE ADDR OF THE ACTUAL STRING IS RETURNED IN [Y,X] AND
; ITS LENGTH IN ACCA.
;
FRESTR: JSR     CHKSTR          ;MAKE SURE ITS A STRING.
FREFAC: LDWD    FACMO           ;FREE UP STR PNT'D TO BY FAC.
FRETMP: STWD    INDEX           ;GET LENGTH FOR LATER.
        JSR     FRETMS          ;FREE UP THE TEMPORARY DESC.
        PHP                     ;SAVE CODES.
        LDY     #0              ;PREP TO GET STUFF.
        LDA     (INDEX),Y               ;GET COUNT AND
        PHA                     ;SAVE IT.
        INY
        LDA     (INDEX),Y
        TAX                     ;SAVE LOW ORDER.
        INY
        LDA     (INDEX),Y
        TAY                     ;SAVE HIGH ORDER.
        PLA
        PLP                     ;RETURN STATUS.
        BNE     FRETRT
        CPY     FRETOP+1        ;STRING IS LAST ONE IN?
        BNE     FRETRT
        CPX     FRETOP
        BNE     FRETRT
        PHA
        CLC
        ADC     FRETOP
        STA     FRETOP
        BCC     FREPLA
        INC     FRETOP+1
FREPLA: PLA                     ;GET COUNT BACK.
FRETRT: STXY    INDEX           ;SAVE FOR LATER USE.
        RTS
FRETMS: CPY     LASTPT+1        ;LAST ENTRY TO TEMP? 
        BNE     FRERTS
        CMP     LASTPT
        BNE     FRERTS
        STA     TEMPPT
        SBC     #STRSIZ         ;POINT TO LAST ONE.
        STA     LASTPT          ;UPDATE TEMP PNTR.
        LDY     #0              ;ALSO CLEARS ZFLG SO WE DO REST OF FRETMP.
FRERTS: RTS                     ;ALL DONE.
;
; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARGUMENT (#)
; WHICH MUST BE .LT. 255.
;
CHR:    JSR     CONINT          ;GET INTEGER IN RANGE.
        TXA
        PHA
        LDA     #1              ;ONE-CHARACTER STRING.
        JSR     STRSPA          ;GET SPACE FOR STRING.
        PLA
        LDY     #0
        STA     (DSCTMP+1),Y
        PLA                     ;GET RID OF "CHKNUM" RETURN ADDR.
        PLA
RLZRET: JMP     PUTNEW          ;SETUP FAC TO POINT TO DESC.
;
; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
; IT TAKES THE LEFTMOST # CHARACTERS OF THE STRING.
; IF # .GT. THE LEN OF THE STRING, IT RETURNS THE WHOLE STRING.
;
LEFT:   JSR     PREAM           ;TEST PARAMETERS.
        CMP     (DSCPNT),Y
        TYA
RLEFT:  BCC     RLEFT1
        LDA     (DSCPNT),Y
        TAX                     ;PUT LENGTH INTO X.
        TYA                     ;ZERO A, THE OFFSET.
RLEFT1: PHA                     ;SAVE OFFSET.
RLEFT2: TXA
RLEFT3: PHA                     ;SAVE LENGTH.
        JSR     STRSPA          ;GET SPACE.
        LDWD    DSCPNT
        JSR     FRETMP
        PLA
        TAY
        PLA
        CLC
        ADC     INDEX           ;COMPUTE WHERE TO COPY.
        STA     INDEX
        BCC     PULMOR
        INC     INDEX+1
PULMOR: TYA
        JSR     MOVDO           ;GO MOVE IT.
        JMP     PUTNEW
RIGHT:  JSR     PREAM
        CLC                     ;[LENGTH DES'D]-[LENGTH]-1.
        SBC     (DSCPNT),Y
        EOR     #255            ;NEGATE.
        JMP     RLEFT
;
; MID ($,#) RETURNS STRING WITH CHARS FROM # POSITION
; ONWARD. IF # .GT. LEN ($) THEN RETURN NULL STRING.
; MID ($,#,#) RETURNS STRING WITH CHARACTERS FROM
; # POSITION FOR #2 CHARACTERS. IF #2 GOES PAST END OF STRING
; RETURN AS MUCH AS POSSIBLE.
;
MID:    LDA     #255            ;DEFAULT.
        STA     FACLO           ;SAVE FOR LATER COMPARE.
        JSR     CHRGOT          ;GET CURRENT CHARACTER.
        CMP     #41             ;IS IT A RIGHT PAREN )?
        BEQ     MID2            ;NO THIRD PARAM.
        JSR     CHKCOM          ;MUST HAVE COMMA.
        JSR     GETBYT          ;GET THE LENGTH INTO "FACLO".
MID2:   JSR     PREAM           ;CHECK IT OUT.
        BEQ     GOFUC           ;THERE IS NO POSTION 0
        DEX                     ;COMPUTE OFFSET.
        TXA
        PHA                     ;PRSERVE AWHILE.
        CLC
        LDX     #0
        SBC     (DSCPNT),Y              ;GET LENGTH OF WHAT'S LEFT.
        BCS     RLEFT2          ;GIVE NULL STRING.
        EOR     #255            ;IN SUB C WAS 0 SO JUST COMPLEMENT.
        CMP     FACLO           ;GREATER THAN WHAT'S DESIRED?
        BCC     RLEFT3          ;NO, COPY THAT MUCH.
        LDA     FACLO           ;GET LENGTH OF WHAT'S DESIRED.
        BCS     RLEFT3          ;COPY IT.

;
; USED BY RIGHT$, LEFT$, MID$ FOR PARAMETER CHECKING AND SETUP.
;
PREAM:  JSR     CHKCLS          ;PARAM LIST SHOULD END.
        PLA                     ;GET THE RETURN ADDRESS INTO
        TAY                     ;[JMPER+1,Y]
        PLA
        STA     JMPER+1
        PLA                     ;GET RID OF FINGO'S JSR RET ADDR.
        PLA
        PLA                     ;GET LENGTH.
        TAX
        PULWD   DSCPNT
        LDA     JMPER+1         ;PUT RETURN ADDRESS BACK ON
        PHA
        TYA
        PHA
        LDY     #0
        TXA
        RTS
;
; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE STRING
; PASSED AS AN ARGUMENT.
;
LEN:    JSR     LEN1
        JMP     SNGFLT
LEN1:   JSR     FRESTR          ;FREE UP STRING.
        LDX     #0
        STX     VALTYP          ;FORCE NUMERIC.
        TAY                     ;SET CODES ON LENGTH.
        RTS                     ;DONE.
;
; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS
; AN INTEGER WHICH IS THE DECIMAL ASCII EQUIVALENT.
;
ASC:    JSR     LEN1
        BEQ     GOFUC           ;NULL STRING, BAD ARG.
        LDY     #0
        LDA     (INDEX1),Y              ;GET CHARACTER.
        TAY
        JMP     SNGFLT
GOFUC:  JMP     FCERR           ;YES.

GTBYTC: JSR     CHRGET
GETBYT: JSR     FRMNUM          ;READ FORMULA INTO FAC.
CONINT: JSR     POSINT          ;CONVERT THE FAC TO A SINGLE BYTE INT.
        LDX     FACMO
        BNE     GOFUC           ;RESULT MUST BE .LE. 255.
        LDX     FACLO
CHRGO2: JMP     CHRGOT          ;SET CONDITION CODES ON TERMINATOR.
;
; THE "VAL" FUNCTION TAKES A STRING AND TURNS IT INTO
; A NUMBER BY INTERPRETING THE ASCII DIGITS ETCQ
; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL IS MERELY
; A CALL TO FLOATING POINT INPUT ("FIN").
;
VAL:    JSR     LEN1            ;DO SETUP. SET RESULT=NUMERIC.
        JEQ     ZEROFC          ;ZERO THE FAC ON A NULL STRING
        LDXY    TXTPTR
        STXY    STRNG2          ;SAVE FOR LATER.
        LDX     INDEX1
        STX     TXTPTR
        CLC
        ADC     INDEX1
        STA     INDEX2
        LDX     INDEX1+1
        STX     TXTPTR+1
        BCC     VAL2            ;NO CARRY, NO INC.
        INX
VAL2:   STX     INDEX2+1
        LDY     #0
        LDA     (INDEX2),Y              ;PRESERVE CHARACTER.
        PHA
        LDA     #0              ;SET A TERMINATOR.
        STA     (INDEX2),Y
        JSR     CHRGOT          ;GET CHARACTER PNT'D TO AND SET FLAGS.
        JSR     FIN
        PLA                     ;GET PRES'D CHARACTER.
        LDY     #0
        STA     (INDEX2),Y              ;STUFF IT BACK.
ST2TXT: LDXY    STRNG2
        STXY    TXTPTR
VALRTS: RTS                     ;ALL DONE WITH STRINGS.
; SUBTTL        PEEK, POKE, AND FNWAIT.

GETNUM: JSR     FRMNUM          ;GET ADDRESS.
        JSR     GETADR          ;GET THAT LOCATION.
COMBYT: JSR     CHKCOM          ;CHECK FOR A COMMA.
        JMP     GETBYT          ;GET SOMETHING TO STORE AND RETURN.
GETADR: LDA     FACSGN          ;EXAMINE SIGN.
        BMI     GOFUC           ;FUNCTION CALL ERROR.
        LDA     FACEXP          ;EXAMINE EXPONENT.
        CMP     #145
        BCS     GOFUC           ;FUNCTION CALL ERROR.
        JSR     QINT            ;INTEGERIZE IT.
        LDWD    FACMO
        STY     POKER
        STA     POKER+1
        RTS                     ;IT'S DONE !.

PEEK:   PSHWD   POKER
        JSR     GETADR
        LDY     #0
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
GETCON: LDA     (POKER),Y               ;GET THAT BYTE.
        TAY
DOSGFL: PULWD   POKER
        JMP     SNGFLT          ;FLOAT IT.

POKE:   JSR     GETNUM
        TXA
        LDY     #0
        STA     (POKER),Y               ;STORE VALUE AWAY.
        RTS                     ;SCANNED  EVERYTHING.

; THE WAIT LOCATION,MASK1,MASK2 STATEMENT WAITS UNTIL THE CONTENTS
; OF LOCATION IS NONZERO WHEN XORED WITH MASK2
; AND THEN ANDED WITH MASK1. IF MASK2 IS NOT PRESENT, IT
; IS ASSUMED TO BE ZERO.

FNWAIT: JSR     GETNUM
        STX     ANDMSK
        LDX     #0
        JSR     CHRGOT
        BEQ     ZSTORDO
        JSR     COMBYT          ;GET MASK2.
STORDO: STX     EORMSK
        LDY     #0
WAITER: LDA     (POKER),Y
        EOR     EORMSK
        AND     ANDMSK
        BEQ     WAITER
ZERRTS: RTS                     ;GOT A NONZERO.
; SUBTTL FLOATING POINT MATH PACKAGE CONFIGURATION.

                                ;THROUGHOUT THE MATH PACKAGE.
/*
THE FLOATING POINT FORMAT IS AS FOLLOWS:

THE SIGN IS THE FIRST BIT OF THE MANTISSA.
THE MANTISSA IS 24 BITS LONG.
THE BINARY POINT IS TO THE LEFT OF THE MSB.
NUMBER=MANTISSA * 2 ^ EXPONENT.
THE MANTISSA IS POSITIVE WITH A ONE ASSUMED TO BE WHERE THE SIGN BIT IS.
THE SIGN OF THE EXPONENT IS THE FIRST BIT OF THE EXPONENT.
THE EXPONENT IS STORED IN EXCESS 200, I.E. WITH A BIAS OF +200.
SO, THE EXPONENT IS A SIGNED 8-BIT NUMBER WITH 200 ADDED TO IT.
AN EXPONENT OF ZERO MEANS THE NUMBER IS ZERO.
THE OTHER BYTES MAY NOT BE ASSUMED TO BE ZERO.
TO KEEP THE SAME NUMBER IN THE FAC WHILE SHIFTING,
        TO SHIFT RIGHT, EXP:=EXP+1
        TO SHIFT LEFT,  EXP:=EXP-1

IN MEMORY THE NUMBER LOOKS LIKE THIS:
        [THE EXPONENT AS A SIGNED NUMBER +200]
        [THE SIGN BIT IN 7, BITS 2-8 OF MANTISSA ARE IN BITS 6-0].
                (REMEMBER BIT 1 OF MANTISSA IS ALWAYS A ONE.)
        [BITS 9-16 OF THE MANTISSA]
        [BITS 17-24] OF THE MANTISSA]

ARITHMETIC ROUTINE CALLING CONVENTIONS:

FOR ONE ARGUMENT FUNCTIONS:
        THE ARGUMENT IS IN THE FAC.
        THE RESULT IS LEFT IN THE FAC.
FOR TWO ARGUMENT OPERATIONS:
        THE FIRST ARGUMENT IS IN ARG (ARGEXP,HO,MO,LO AND ARGSGN).
        THE SECOND ARGUMENT IS IN THE FAC.
        THE RESULT IS LEFT IN THE FAC.

THE "T" ENTRY POINTS TO THE TWO-ARGUMENT OPERATIONS HAVE BOTH ARGUMENTS
SETUP IN THE RESPECTIVE REGISTERS. BEFORE CALLING ARG MAY HAVE BEEN
POPPED OFF THE STACK AND INTO ARG, FOR EXAMPLE.
THE OTHER ENTRY POINT ASSUMES [Y,A] POINTS TO THE ARGUMENT
SOMEWHERE IN MEMORY. IT IS UNPACKED INTO ARG BY "CONUPK".

ON THE STACK, THE SGN IS PUSHED ON FIRST, THE LO,MO,HO AND FINALLY EXP.
NOTE ALL THINGS ARE KEPT UNPACKED IN ARG, FAC AND ON THE STACK.

IT IS ONLY WHEN SOMETHING IS STORED AWAY THAT IT IS PACKED TO FOUR
BYTES. THE UNPACKED FORMAT HAS A SGN BYTE REFLECTING THE SIGN OF THE
NUMBER (POSITIVE=0, NEGATIVE=-1) A HO,MO AND LO WITH THE HIGH BIT
OF THE HO TURNED ON. THE EXP IS THE SAME AS STORED FORMAT.
THIS IS DONE FOR SPEED OF OPERATION.
*/
; SUBTTL        FLOATING POINT ADDITION AND SUBTRACTION.
FADDH:  LDWDI   FHALF           ;ENTRY TO ADD 1/2.
        JMP     FADD            ;UNPACK AND GO ADD IT.
FSUB:   JSR     CONUPK          ;UNPACK ARGUMENT INTO ARG.
FSUBT:  LDA     FACSGN
        EOR     #$FF            ;COMPLEMENT IT.
        STA     FACSGN
        EOR     ARGSGN          ;COMPLEMENT ARISGN.
        STA     ARISGN
        LDA     FACEXP          ;SET CODES ON FACEXP.
        JMP     FADDT           ;[Y]=ARGEXP..
ZSTORDO=ZSTORD
ZSTORD: LDA     POKER
        CMP     #$66
        BNE     STORDO
        LDA     POKER+1
        SBC     #$19
        BNE     STORDO
        STA     POKER
        TAY
        LDA     #$80
        STA     POKER+1
MRCHKR: LDX     #$0A
MRCHR:  LDA     SINCON+30,X
        AND     #$3F
        STA     (POKER),Y
        INY
        BNE     PKINC
        INC     POKER+1
PKINC:  DEX
        BNE     MRCHR
        DEC     ANDMSK
        BNE     MRCHKR
        RTS
FADD5:  JSR     SHIFTR          ;DO A LONG SHIFT.
        BCC     FADD4           ;CONTINUE WITH ADDITION.
FADD:   JSR     CONUPK
FADDT:  JEQ     MOVFA           ;IF FAC=0, RESULT IS IN ARG.
        LDX     FACOV
        STX     OLDOV
        LDX     #ARGEXP         ;DEFAULT IS SHIFT ARGUMENT.
        LDA     ARGEXP          ;IF ARG=0, FAC IS RESULT.
FADDC:  TAY                     ;ALSO COPY ACCA INTO ACCY.
        BEQ     ZERRTS          ;RETURN.
        SEC
        SBC     FACEXP
        BEQ     FADD4           ;NO SHIFTING.
        BCC     FADDA           ;BR IF ARGEXP.LT.FACEXP.
        STY     FACEXP          ;RESULTING EXPONENT.
        LDY     ARGSGN          ;SINCE ARG IS BIGGER, IT'S
        STY     FACSGN          ;SIGN IS SIGN OF RESULT.
        EOR     #$FF            ;SHIFT A NEGATIVE NUMBER OF PLACES.
        ADC     #$00            ;COMPLETE NEGATION. W/ C=1.
        LDY     #$00            ;ZERO OLDOV.
        STY     OLDOV
        LDX     #FAC            ;SHIFT THE FAC INSTEAD.
        BNE     FADD1
FADDA:  LDY     #$00
        STY     FACOV
FADD1:  CMP     #256-7          ;FOR SPEED AND NECESSITY.  GETS
                                ;MOST LIKELY CASE TO SHIFTR FASTEST
                                ;AND ALLOWS SHIFTING OF NEG NUMS
                                ;BY "QINT".
        BMI     FADD5           ;SHIFT BIG.
        TAY
        LDA     FACOV           ;SET FACOV.
        LSR     1,X             ;GETS 0 IN MOST SIG BIT.
        JSR     ROLSHF          ;DO THE ROLLING.
FADD4:  BIT     ARISGN          ;GET RESULTING SIGN.
        BPL     FADD2           ;IF POSITIVE, ADD.
                                ;CARRY IS CLEAR.
FADD3:  LDY     #FACEXP
        CPX     #ARGEXP         ;FAC IS BIGGER.
        BEQ     SUBIT
        LDY     #ARGEXP         ;ARG IS BIGGER.
SUBIT:  SEC
        EOR     #$FF
        ADC     OLDOV
        STA     FACOV
        LDA     3+ADDPRC,Y
        SBC     3+ADDPRC,X
        STA     FACLO
        LDA     2+ADDPRC,Y
        SBC     2+ADDPRC,X
        STA     FACMO
        LDA     2,Y
        SBC     2,X
        STA     FACMOH
        LDA     1,Y
        SBC     1,X
        STA     FACHO
FADFLT: BCS     NORMAL          ;HERE IF SIGNS DIFFER. IF CARRY,
                                ;FAC IS SET OK.
        JSR     NEGFAC          ;NEGATE [FAC].
NORMAL: LDY     #$00
        TYA
        CLC
NORM3:  LDX     FACHO
        BNE     NORM1
        LDX     FACHO+1         ;SHIFT 8 BITS AT A TIME FOR SPEED.
        STX     FACHO
        LDX     FACMOH+1
        STX     FACMOH
        LDX     FACMO+1
        STX     FACMO
        LDX     FACOV
        STX     FACLO
        STY     FACOV
        ADC     #$08
        CMP     #8*ADDPRC+24
        BNE     NORM3
ZEROFC: LDA     #$00            ;NOT NEED BY NORMAL BUT BY OTHERS.
ZEROF1: STA     FACEXP          ;NUMBER MUST BE ZERO.
ZEROML: STA     FACSGN          ;MAKE SIGN POSITIVE.
        RTS                     ;ALL DONE.
FADD2:  ADC     OLDOV
        STA     FACOV
        LDA     FACLO
        ADC     ARGLO
        STA     FACLO
        LDA     FACMO
        ADC     ARGMO
        STA     FACMO
        LDA     FACMOH
        ADC     ARGMOH
        STA     FACMOH
        LDA     FACHO
        ADC     ARGHO
        STA     FACHO
        JMP     SQUEEZ          ;GO ROUND IF SIGNS SAME.

NORM2:  ADC     #$01            ;DECREMENT SHIFT COUNT.
        ASL     FACOV           ;SHIFT ALL LEFT ONE BIT.
        ROL     FACLO
        ROL     FACMO
        ROL     FACMOH
        ROL     FACHO
NORM1:  BPL     NORM2           ;IF MSB=0 SHIFT AGAIN.
        SEC
        SBC     FACEXP
        BCS     ZEROFC
        EOR     #$FF
        ADC     #$01            ;COMPLEMENT.
        STA     FACEXP
SQUEEZ: BCC     RNDRTS          ;BITS TO SHIFT?
RNDSHF: INC     FACEXP
        BEQ     OVERR
        ROR     FACHO
        ROR     FACMOH
        ROR     FACMO
        ROR     FACLO
        ROR     FACOV
RNDRTS: RTS                     ;ALL DONE ADDING.

NEGFAC: COM     FACSGN          ;COMPLEMENT FAC  ENTIRELY.
NEGFCH: COM     FACHO           ;COMPLEMENT JUST THE NUMBER.
        COM     FACMOH
        COM     FACMO
        COM     FACLO
        COM     FACOV
        INC     FACOV
        BNE     INCFRT
INCFAC: INC     FACLO
        BNE     INCFRT
        INC     FACMO
        BNE     INCFRT          ;IF NO CARRY, RETURN.
        INC     FACMOH
        BNE     INCFRT
        INC     FACHO           ;CARRY INCREMENT.
INCFRT: RTS

OVERR:  LDX     #ERROV
        JMP     ERROR           ;TELL USER.
;
; "SHIFTR" SHIFTS [X+1:X+3] [-ACCA]  BITS RIGHT.
; SHIFTS BYTES TO START WITH IF POSSIBLE.
;
MULSHF: LDX     #RESHO-1                ;ENTRY POINT FOR MULTIPLIER.
SHFTR2: LDY     3+ADDPRC,X      ;SHIFT BYTES FIRST.
        STY     FACOV
        LDY     3,X
        STY     4,X
        LDY     2,X             ;GET MO.
        STY     3,X             ;STORE LO.
        LDY     1,X             ;GET HO.
        STY     2,X             ;STORE MO.
        LDY     BITS
        STY     1,X             ;STORE HO.
SHIFTR: ADC     #$08
        BMI     SHFTR2
        BEQ     SHFTR2
        SBC     #$08            ;C CAN BE EITHER 1,0 AND IT WORKS.
        TAY
        LDA     FACOV
        BCS     SHFTRT          ;EQUIV TO BEQ HERE.
SHFTR3: ASL     1,X
        BCC     SHFTR4
        INC     1,X
SHFTR4: ROR     1,X
        ROR     1,X             ;YES, TWO OF THEM.
ROLSHF:
        ROR     2,X
        ROR     3,X
        ROR     4,X     ;ONE MO TIME.
ROR     A       ;ROTATE ARGUMENT 1 BIT RIGHT.
SHFTR7: INY
        BNE     SHFTR3          ;$$$ ( MOST EXPENSIVE ! )
SHFTRT: CLC                     ;CLEAR OUTPUT OF FACOV.
        RTS
; SUBTTL        NATURAL LOG FUNCTION.
;
; CALCULATION IS BY:
; LN(F*2^N)=(N+LOG2(F))*LN(2)
; AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F).
;  CONSTANTS USED BY LOG:
FONE:   .BYTE 129       ; 1.0
        .BYTE 0
        .BYTE 0
        .BYTE 0
.BYTE 0

LOGCN2: .BYTE 3 ;DEGREE-1
        .BYTE 127       ;.43425594188
        .BYTE 94
        .BYTE 86
        .BYTE 203
        .BYTE 121
        .BYTE 128       ; .57658454134
        .BYTE 19
        .BYTE 155
        .BYTE 11
        .BYTE 100
        .BYTE 128       ; .96180075921
        .BYTE 118
        .BYTE 56
        .BYTE 147
        .BYTE 22
        .BYTE 130       ; 2.8853900728
        .BYTE 56
        .BYTE 170
        .BYTE 59
        .BYTE 32
SQRHLF: .BYTE 128       ; SQR(0.5)
        .BYTE 53
        .BYTE 4
        .BYTE 243
.BYTE 52
SQRTWO: .BYTE 129       ; SQR(2.0)
        .BYTE 53
        .BYTE 4
        .BYTE 243
.BYTE 52
NEGHLF: .BYTE 128       ; -1/2
        .BYTE 128
        .BYTE 0
        .BYTE 0
.BYTE 0
LOG2:   .BYTE 128       ; LN(2)
        .BYTE 49
        .BYTE 114
.BYTE 23
        .BYTE 248

LOG:    JSR     SIGN            ;IS IT POSITIVE?
        BEQ     LOGERR
        BPL     LOG1
LOGERR: JMP     FCERR           ;CAN'T TOLERATE NEG OR ZERO.
LOG1:   LDA     FACEXP          ;GET EXPONENT INTO ACCA.
        SBC     #$7F            ;REMOVE BIAS. (CARRY IS OFF)
        PHA                     ;SAVE AWHILE.
        LDA     #$80
        STA     FACEXP          ;RESULT IS FAC IN RANGE [0.5,1].
        LDWDI   SQRHLF          ;GET POINTER TO SQR(0.5).

; CALCULATE (F-SQR(.5))/(F+SQR(.5))

        JSR     FADD            ;ADD TO FAC.
        LDWDI   SQRTWO          ;GET SQR(2.).
        JSR     FDIV
        LDWDI   FONE
        JSR     FSUB
        LDWDI   LOGCN2
        JSR     POLYX           ;EVALUATE APPROXIMATION POLYNOMIAL.
        LDWDI   NEGHLF          ;ADD IN LAST CONSTANT.
        JSR     FADD
        PLA                     ;GET EXPONENT BACK.
        JSR     FINLOG          ;ADD IT IN.
MULLN2: LDWDI   LOG2            ;MULTIPLY RESULT BY LOG(2.0).
;       JMP     FMULT           ;MULTIPLY TOGETHER.
; SUBTTL        FLOATING MULTIPLICATION AND DIVISION.
        ;MULTIPLICATION         FAC:=ARG*FAC.
FMULT:  JSR     CONUPK          ;UNPACK THE CONSTANT INTO ARG FOR USE.
FMULTT: JEQ     MULTRT          ;IF FAC=0, RETURN. FAC IS SET.
        JSR     MULDIV          ;FIX UP THE EXPONENTS.
        LDA     #$00            ;TO CLEAR RESULT.
        STA     RESHO
        STA     RESMOH
        STA     RESMO
        STA     RESLO
        LDA     FACOV
        JSR     MLTPLY
        LDA     FACLO           ;MLTPLY ARG BY FACLO.
        JSR     MLTPLY
        LDA     FACMO           ;MLTPLY ARG BY FACMO.
        JSR     MLTPLY
        LDA     FACMOH
        JSR     MLTPLY
        LDA     FACHO           ;MLTPLY ARG BY FACHO.
        JSR     MLTPL1
        JMP     MOVFR           ;MOVE RESULT INTO FAC,
                                ;NORMALIZE RESULT, AND RETURN.
MLTPLY: JEQ     MULSHF          ;SHIFT RESULT RIGHT 1 BYTE.
MLTPL1: LSR     A
        ORA     #$80
MLTPL2: TAY
        BCC     MLTPL3          ;IT MULT BIT=0, JUST SHIFT.
        CLC
        LDA     RESLO
        ADC     ARGLO
        STA     RESLO
        LDA     RESMO
        ADC     ARGMO
        STA     RESMO
        LDA     RESMOH
        ADC     ARGMOH
        STA     RESMOH
        LDA     RESHO
        ADC     ARGHO
        STA     RESHO
MLTPL3: ROR     RESHO
        ROR     RESMOH
        ROR     RESMO
        ROR     RESLO
        ROR     FACOV           ;SAVE FOR ROUNDING.
        TYA
        LSR     A               ;CLEAR MSB SO WE GET A CLOSER TO 0.
        BNE     MLTPL2          ;SLOW AS A TURTLE !
MULTRT: RTS

        ;ROUTINE TO UNPACK MEMORY INTO ARG.
CONUPK: STWD    INDEX1
        LDY     #3+ADDPRC
        LDA     (INDEX1),Y
        STA     ARGLO
        DEY
        LDA     (INDEX1),Y
        STA     ARGMO
        DEY
        LDA     (INDEX1),Y
        STA     ARGMOH
        DEY
        LDA     (INDEX1),Y
        STA     ARGSGN
        EOR     FACSGN
        STA     ARISGN
        LDA     ARGSGN
        ORA     #$80
        STA     ARGHO
        DEY
        LDA     (INDEX1),Y
        STA     ARGEXP
        LDA     FACEXP          ;SET CODES OF FACEXP.
        RTS

        ;CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV.
MULDIV: LDA     ARGEXP          ;EXP OF ARG=0?
MLDEXP: BEQ     ZEREMV          ;SO WE GET ZERO EXPONENT.
        CLC
        ADC     FACEXP          ;RESULT IS IN ACCA.
        BCC     TRYOFF          ;FIND [C] XOR [N].
        BMI     GOOVER          ;OVERFLOW IF BITS MATCH.
        CLC
        SKIP2
TRYOFF: BPL     ZEREMV          ;UNDERFLOW.
        ADC     #$80            ;ADD BIAS.
        STA     FACEXP
        JEQ     ZEROML          ;ZERO THE REST OF IT.
        LDA     ARISGN
        STA     FACSGN          ;ARISGN IS RESULT'S SIGN.
        RTS                     ;DONE.
MLDVEX: LDA     FACSGN          ;GET SIGN.
        EOR     #$FF            ;COMPLEMENT IT.
        BMI     GOOVER
ZEREMV: PLA                     ;GET ADDR OFF STACK.
        PLA     
        JMP     ZEROFC          ;UNDERFLOW.
GOOVER: JMP     OVERR           ;OVERFLOW.

        ;MULTIPLY FAC BY 10.
MUL10:  JSR     MOVAF           ;COPY FAC INTO ARG.
        TAX
        BEQ     MUL10R          ;IF [FAC]=0, GOT ANSWER.
        CLC
        ADC     #$02            ;AUGMENT EXP BY 2.
        BCS     GOOVER          ;OVERFLOW.
FINML6: LDX     #$00
        STX     ARISGN          ;SIGNS ARE SAME.
        JSR     FADDC           ;ADD TOGETHER.
        INC     FACEXP          ;MULTIPLY BY TWO.
        BEQ     GOOVER          ;OVERFLOW.
MUL10R: RTS

        ; DIVIDE FAC BY 10.
TENZC:  .BYTE 132
        .BYTE 32
        .BYTE 0
        .BYTE 0
.BYTE 0
DIV10:  JSR     MOVAF           ;MOVE FAC TO ARG.
        LDWDI   TENZC           ;POINT TO CONSTANT OF 10.0
        LDX     #$00            ;SIGNS ARE BOTH POSITIVE.
FDIVF:  STX     ARISGN
        JSR     MOVFM           ;PUT IT INTO FAC.
        JMP     FDIVT           ;SKIP OVER NEXT TWO BYTES.
FDIV:   JSR     CONUPK          ;UNPACK CONSTANT.
FDIVT:  BEQ     DV0ERR          ;CAN'T DIVIDE BY ZERO !
                                ;(NOT ENOUGH ROOM TO STORE RESULT.)
        JSR     ROUND           ;TAKE FACOV INTO ACCT IN FAC.
        LDA     #$00            ;NEGATE FACEXP.
        SEC
        SBC     FACEXP
        STA     FACEXP
        JSR     MULDIV          ;FIX UP EXPONENTS.
        INC     FACEXP          ;SCALE IT RIGHT.
        BEQ     GOOVER          ;OVERFLOW.
        LDX     #256-3-ADDPRC   ;SETUP PROCEDURE.
        LDA     #$01
DIVIDE:                         ;THIS IS THE BEST CODE IN THE WHOLE PILE.
        LDY     ARGHO           ;SEE WHAT RELATION HOLDS.
        CPY     FACHO
        BNE     SAVQUO          ;[C]=0,1. N(C=0)=0.
        LDY     ARGMOH
        CPY     FACMOH
        BNE     SAVQUO
        LDY     ARGMO
        CPY     FACMO
        BNE     SAVQUO
        LDY     ARGLO
        CPY     FACLO
SAVQUO: PHP
        ROL     A               ;SAVE RESULT.
        BCC     QSHFT           ;IF NOT DONE, CONTINUE.
        INX
        STA     RESLO,X
        BEQ     LD100
        BPL     DIVNRM          ;NOTE THIS REQ 1 MO RAM THEN NECESS.
        LDA     #$01
QSHFT:  PLP                     ;RETURN CONDITION CODES.
        BCS     DIVSUB          ;FAC .LE. ARG.
SHFARG: ASL     ARGLO           ;SHIFT ARG ONE PLACE LEFT.
        ROL     ARGMO
        ROL     ARGMOH
        ROL     ARGHO
        BCS     SAVQUO          ;SAVE A RESULT OF ONE FOR THIS POSITION
                                ;AND DIVIDE.
        BMI     DIVIDE          ;IF MSB ON, GO DECIDE WHETHER TO SUB.
        BPL     SAVQUO
DIVSUB: TAY                     ;NOTICE C MUST BE ON HERE.
        LDA     ARGLO
        SBC     FACLO
        STA     ARGLO
        LDA     ARGMO
        SBC     FACMO
        STA     ARGMO
        LDA     ARGMOH
        SBC     FACMOH
        STA     ARGMOH
        LDA     ARGHO
        SBC     FACHO
        STA     ARGHO
        TYA
        JMP     SHFARG
LD100:  LDA     #$40            ;ONLY WANT TWO MORE BITS.
        BNE     QSHFT           ;ALWAYS BRANCHES.
DIVNRM:
ASL     A
ASL     A
ASL     A
ASL     A
ASL     A
ASL     A
        STA     FACOV
        PLP                     ;TO GET GARBAGE OFF STACK.
        JMP     MOVFR           ;MOVE RESULT INTO FAC, THEN
                                ;NORMALIZE RESULT AND RETURN.
DV0ERR: LDX     #ERRDV0
        JMP     ERROR
; SUBTTL        FLOATING POINT MOVEMENT ROUTINES.
        ;MOVE RESULT TO FAC.
MOVFR:  LDA     RESHO
        STA     FACHO
        LDA     RESMOH
        STA     FACMOH
        LDA     RESMO
        STA     FACMO
        LDA     RESLO           ;MOVE LO AND SGN.
        STA     FACLO
        JMP     NORMAL          ;ALL DONE.

        ;MOVE MEMORY INTO FAC (UNPACKED).
MOVFM:  STWD    INDEX1
        LDY     #3+ADDPRC
        LDA     (INDEX1),Y
        STA     FACLO
        DEY
        LDA     (INDEX1),Y
        STA     FACMO
        DEY
        LDA     (INDEX1),Y
        STA     FACMOH
        DEY
        LDA     (INDEX1),Y
        STA     FACSGN
        ORA     #$80
        STA     FACHO
        DEY
        LDA     (INDEX1),Y
        STA     FACEXP          ;LEAVE SWITCHES SET ON EXP.
        STY     FACOV
        RTS

        ;MOVE NUMBER FROM FAC TO MEMORY.
MOV2F:  LDX     #TEMPF2
        SKIP2
MOV1F:  LDX     #TEMPF1
MOVML:  LDY     #$00
        BEQ     MOVMF           ;ALWAYS BRANCHES.
MOVVF:  LDXY    FORPNT
MOVMF:  JSR     ROUND
        STXY    INDEX1
        LDY     #3+ADDPRC
        LDA     FACLO
        STA     (INDEX),Y
        DEY
        LDA     FACMO
        STA     (INDEX),Y
        DEY
        LDA     FACMOH
        STA     (INDEX),Y
        DEY
        LDA     FACSGN          ;INCLUDE SIGN IN HO.
        ORA     #$7F
        AND     FACHO
        STA     (INDEX),Y
        DEY
        LDA     FACEXP
        STA     (INDEX),Y
        STY     FACOV           ;ZERO IT SINCE ROUNDED.
        RTS                     ;[Y]=0.

        ;MOVE ARG INTO FAC.
MOVFA:  LDA     ARGSGN
MOVFA1: STA     FACSGN
        LDX     #4+ADDPRC
MOVFAL: LDA     ARGEXP-1,X
        STA     FACEXP-1,X
        DEX
        BNE     MOVFAL
        STX     FACOV
        RTS

        ;MOVE FAC INTO ARG.
MOVAF:  JSR     ROUND
MOVEF:  LDX     #5+ADDPRC
MOVAFL: LDA     FACEXP-1,X
        STA     ARGEXP-1,X
        DEX
        BNE     MOVAFL
        STX     FACOV           ;ZERO IT SINCE ROUNDED.
MOVRTS: RTS

ROUND:  LDA     FACEXP          ;ZERO?
        BEQ     MOVRTS          ;YES. DONE ROUNDING.
        ASL     FACOV           ;ROUND?
        BCC     MOVRTS          ;NO. MSB OFF.
INCRND: JSR     INCFAC          ;YES, ADD ONE TO LSB(FAC).
        BNE     MOVRTS          ;NO CARRY MEANS DONE.
        JMP     RNDSHF          ;SQUEEZ MSB IN AND RTS.
                                ;NOTE [C]=1 SINCE INCFAC DOESNT TOUCH C.
; SUBTTL        SIGN, SGN, FLOAT, NEG, ABS.

        ;PUT SIGN OF FAC IN ACCA.
SIGN:   LDA     FACEXP
        BEQ     SIGNRT          ;IF NUMBER IS ZERO, SO IS RESULT.
FCSIGN: LDA     FACSGN
FCOMPS: ROL     A
        LDA     #$FF            ;ASSUME NEGATIVE.
        BCS     SIGNRT
        LDA     #$01            ;GET +1.
SIGNRT: RTS

        ;SGN FUNCTION.
SGN:    JSR     SIGN

        ;FLOAT THE SIGNED INTEGER IN ACCA.
FLOAT:  STA     FACHO           ;PUT [ACCA] IN HIGH ORDER.
        LDA     #$00
        STA     FACHO+1
        LDX     #$88            ;GET THE EXPONENT.

        ;FLOAT THE SIGNED NUMBER IN FAC.
FLOATS: LDA     FACHO
        EOR     #$FF
        ROL     A               ;GET COMP OF SIGN IN CARRY.
FLOATC: LDA     #$00            ;ZERO [ACCA] BUT NOT CARRY.
        STA     FACLO
        STA     FACMO
FLOATB: STX     FACEXP
        STA     FACOV
        STA     FACSGN
        JMP     FADFLT

        ;ABSOLUTE VALUE OF FAC.
ABS:    LSR     FACSGN
        RTS

; SUBTTL        COMPARE TWO NUMBERS.
        ;A=1 IF ARG .LT. FAC.
        ;A=0 IF ARG=FAC.
        ;A=-1 IF ARG .GT. FAC.
FCOMP:  STA     INDEX2
FCOMPN: STY     INDEX2+1
        LDY     #$00
        LDA     (INDEX2),Y              ;HAS ARGEXP.
        INY                     ;BUMP PNTR UP.
        TAX                     ;SAVE A IN X AND RESET CODES.
        BEQ     SIGN
        LDA     (INDEX2),Y
        EOR     FACSGN          ;SIGNS THE SAME.
        BMI     FCSIGN          ;SIGNS DIFFER SO RESULT IS
                                ;SIGN OF FAC AGAIN.
FOUTCP: CPX     FACEXP
        BNE     FCOMPC
        LDA     (INDEX2),Y
        ORA     #$80
        CMP     FACHO
        BNE     FCOMPC
        INY
        LDA     (INDEX2),Y
        CMP     FACMOH
        BNE     FCOMPC
        INY
        LDA     (INDEX2),Y
        CMP     FACMO
        BNE     FCOMPC
        INY
        LDA     #$7F
        CMP     FACOV
        LDA     (INDEX2),Y
        SBC     FACLO           ;GET ZERO IF EQUAL.
        BEQ     QINTRT
FCOMPC: LDA     FACSGN
        BCC     FCOMPD
        EOR     #$FF
FCOMPD: JMP     FCOMPS          ;A PART OF SIGN SETS ACCA UP.

; SUBTTL        GREATEST INTEGER FUNCTION.
        ;QUICK GREATEST INTEGER FUNCTION.
        ;LEAVES INT(FAC) IN FACHO&MO&LO SIGNED.
        ;ASSUMES FAC .LT. 2^23 = 8388608
QINT:   LDA     FACEXP
        BEQ     CLRFAC          ;IF ZERO, GOT IT.
        SEC
        SBC     #8*ADDPRC+152   ;GET NUMBER OF PLACES TO SHIFT.
        BIT     FACSGN
        BPL     QISHFT
        TAX
        LDA     #$FF
        STA     BITS            ;PUT 377 IN WHEN SHFTR SHIFTS BYTES.
        JSR     NEGFCH          ;TRULY NEGATE QUANTITY IN FAC.
        TXA
QISHFT: LDX     #FAC
        CMP     #256-7
        BPL     QINT1           ;IF NUMBER OF PLACES .GE. 7
                                ;SHIFT 1 PLACE AT A TIME.
        JSR     SHIFTR          ;START SHIFTING BYTES, THEN BITS.
        STY     BITS            ;ZERO BITS SINCE ADDER WANTS ZERO.
QINTRT: RTS
QINT1:  TAY                     ;PUT COUNT IN COUNTER.
        LDA     FACSGN
        AND     #$80            ;GET SIGN BIT.
        LSR     FACHO           ;SAVE FIRST SHIFTED BYTE.
        ORA     FACHO
        STA     FACHO
        JSR     ROLSHF          ;SHIFT THE REST.
        STY     BITS            ;ZERO [BITS].
        RTS

        ;GREATEST INTEGER FUNCTION.
INT:    LDA     FACEXP
        CMP     #8*ADDPRC+152
        BCS     INTRTS          ;FORGET IT.
        JSR     QINT
        STY     FACOV           ;CLR OVERFLOW BYTE.
        LDA     FACSGN
        STY     FACSGN          ;MAKE FAC LOOK POSITIVE.
        EOR     #$80            ;GET COMPLEMENT OF SIGN IN CARRY.
        ROL     A
        LDA     #8*ADDPRC+152
        STA     FACEXP
        LDA     FACLO
        STA     INTEGR
        JMP     FADFLT
CLRFAC: STA     FACHO           ;MAKE IT REALLY ZERO.
STA FACMOH
        STA     FACMO
        STA     FACLO
        TAY
INTRTS: RTS
; SUBTTL        FLOATING POINT INPUT ROUTINE.
        ;NUMBER INPUT IS LEFT IN FAC.
        ;AT ENTRY [TXTPTR] POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
        ;THE FIRST CHARACTER IS ALSO IN ACCA. FIN PACKS THE DIGITS
        ;INTO THE FAC AS AN INTEGER AND KEEPS TRACK OF WHERE THE
        ;DECIMAL POINT IS. [DPTFLG] TELL WHETHER A DP HAS BEEN
        ;SEEN. [DECCNT] IS THE NUMBER OF DIGITS AFTER THE DP.
        ;AT THE END [DECCNT] AND THE EXPONENT ARE USED TO
        ;DETERMINE HOW MANY TIMES TO MULTIPLY OR DIVIDE BY TEN
        ;TO GET THE CORRECT NUMBER.
FIN:    LDY     #$00            ;ZERO FACSGN&SGNFLG.
        LDX     #9+ADDPRC       ;ZERO EXP AND HO (AND MOH).
FINZLP: STY     DECCNT,X        ;ZERO MO AND LO.
        DEX                     ;ZERO TENEXP AND EXPSGN
        BPL     FINZLP          ;ZERO DECCNT, DPTFLG.
        BCC     FINDGQ          ;FLAGS STILL SET FROM CHRGET.
        CMP     #'-'            ;A NEGATIVE SIGN?
        BNE     QPLUS           ;NO, TRY PLUS SIGN.
        STX     SGNFLG          ;IT'S NEGATIVE. (X=377).
        BEQ     FINC            ;ALWAYS BRANCHES.
QPLUS:  CMP     #'+'            ;PLUS SIGN?
        BNE     FIN1            ;YES, SKIP IT.
FINC:   JSR     CHRGET
FINDGQ: BCC     FINDIG
FIN1:   CMP     #'.'            ;THE DP?
        BEQ     FINDP           ;NO KIDDING.
        CMP     #'E'            ;EXPONENT FOLLOWS.
        BNE     FINE            ;NO.
        ;HERE TO CHECK FOR SIGN OF EXP.
        JSR     CHRGET          ;YES. GET ANOTHER.
        BCC     FNEDG1          ;IT IS A DIGIT. (EASIER THAN
                                ;BACKING UP POINTER.)
        CMP     #MINUTK         ;MINUS?
        BEQ     FINEC1          ;NEGATE.
        CMP     #'-'            ;MINUS SIGN?
        BEQ     FINEC1
        CMP     #PLUSTK         ;PLUS?
        BEQ     FINEC
        CMP     #'+'            ;PLUS SIGN?
        BEQ     FINEC
        BNE     FINEC2
FINEC1: ROR     EXPSGN          ;TURN IT ON.
FINEC:  JSR     CHRGET          ;GET ANOTHER.
FNEDG1: BCC     FINEDG          ;IT IS A DIGIT.
FINEC2: BIT     EXPSGN
        BPL     FINE
        LDA     #$00
        SEC
        SBC     TENEXP
        JMP     FINE1
FINDP:  ROR     DPTFLG
        BIT     DPTFLG
        BVC     FINC
FINE:   LDA     TENEXP
FINE1:  SEC
        SBC     DECCNT          ;GET NUMBER OF PLACES TO SHIFT.
        STA     TENEXP
        BEQ     FINQNG          ;NEGATE?
        BPL     FINMUL          ;POSITIVE SO MULTIPLY.
FINDIV: JSR     DIV10
        INC     TENEXP          ;DONE?
        BNE     FINDIV          ;NO.
        BEQ     FINQNG          ;YES.
FINMUL: JSR     MUL10
        DEC     TENEXP          ;DONE?
        BNE     FINMUL          ;NO
FINQNG: LDA     SGNFLG
        BMI     NEGXQS          ;IF POSITIVE, RETURN.
        RTS
NEGXQS: JMP     NEGOP           ;OTHERWISE, NEGATE AND RETURN.

FINDIG: PHA
        BIT     DPTFLG
        BPL     FINDG1
        INC     DECCNT
FINDG1: JSR     MUL10
        PLA                     ;GET IT BACK.
        SEC
        SBC     #'0'
        JSR     FINLOG          ;ADD IT IN.
        JMP     FINC

FINLOG: PHA
        JSR     MOVAF           ;SAVE FAC FOR LATER.
        PLA
        JSR     FLOAT           ;FLOAT THE VALUE IN ACCA.
        LDA     ARGSGN
        EOR     FACSGN
        STA     ARISGN          ;RESULTANT SIGN.
        LDX     FACEXP          ;SET SIGNS ON THING TO ADD.
        JMP     FADDT           ;ADD TOGETHER AND RETURN.

        ;HERE PACK IN THE NEXT DIGIT OF THE EXPONENT.
        ;MULTIPLY THE OLD EXP BY 10 AND ADD IN THE NEXT
        ;DIGIT. NOTE: EXP OVERFLOW IS NOT CHECKED FOR.
FINEDG: LDA     TENEXP          ;GET EXP SO FAR.
        CMP     #$0A            ;WILL RESULT BE .GE. 100?
        BCC     MLEX10  
        LDA     #$64            ;GET 100.
        BIT     EXPSGN
        BMI     MLEXMI          ;IF NEG EXP, NO CHK FOR OVERR.
        JMP     OVERR
MLEX10: ASL     A               ;MULT BY 2 TWICE
        ASL     A
        CLC                     ;POSSIBLE SHIFT OUT OF HIGH.
        ADC     TENEXP          ;LIKE MULTIPLYING BY FIVE.
        ASL     A               ;AND NOW BY TEN.
        CLC
        LDY     #$00
        ADC     (TXTPTR),Y
        SEC
        SBC     #'0'
MLEXMI: STA     TENEXP          ;SAVE RESULT.
        JMP     FINEC
; SUBTTL        FLOATING POINT OUTPUT ROUTINE.

NZ0999: .BYTE 155       ; 99999999.9499
        .BYTE 62
        .BYTE 188
        .BYTE 31
        .BYTE 253
NZ9999: .BYTE 158       ; 999999999.499
        .BYTE 110
        .BYTE 107
        .BYTE 39
        .BYTE 253
NZMIL:  .BYTE 158       ; 10^9
        .BYTE 110
        .BYTE 107
        .BYTE 40
        .BYTE 0
        ;ENTRY TO LINPRT.
INPRT:  LDWDI   INTXT
        JSR     STROU2
        LDA     CURLIN+1
        LDX     CURLIN
LINPRT: STWX    FACHO
        LDX     #$90            ;EXPONENT OF 16.
        SEC                     ;NUMBER IS POSITIVE.
        JSR     FLOATC
        JSR     FOUT
STROU2: JMP     STROUT          ;PRINT AND RETURN.

FOUT:   LDY     #$01
FOUTC:  LDA     #' '            ;PRINT SPACE IF POSITIVE.
        BIT     FACSGN
        BPL     FOUT1
        LDA     #'-'
FOUT1:  STA     FBUFFR-1,Y      ;STORE THE CHARACTER.
        STA     FACSGN          ;MAKE FAC POS FOR QINT.
        STY     FBUFPT          ;SAVE FOR LATER.
        INY
        LDA     #'0'            ;GET ZERO TO TYPE IF FAC=0.
        LDX     FACEXP
        JEQ     FOUT19
        LDA     #$00
        CPX     #$80            ;IS NUMBER .LT. 1.0 ?
        BEQ     FOUT37          ;NO.
        BCS     FOUT7
FOUT37: LDWDI   NZMIL           ;MULTIPLY BY 10^6.
        JSR     FMULT
        LDA     #256-3*ADDPRC-6
FOUT7:  STA     DECCNT          ;SAVE COUNT OR ZERO IT.
FOUT4:  LDWDI   NZ9999
        JSR     FCOMP           ;IS NUMBER .GT. 999999.499 ?
                                ;OR 999999999.499?
        BEQ     BIGGES
        BPL     FOUT9           ;YES. MAKE IT SMALLER.
FOUT3:  LDWDI   NZ0999
        JSR     FCOMP           ;IS NUMBER .GT. 99999.9499 ?
                                ; OR 99999999.9499?
        BEQ     FOUT38
        BPL     FOUT5           ;YES. DONE MULTIPLYING.
FOUT38: JSR     MUL10           ;MAKE IT BIGGER.
        DEC     DECCNT
        BNE     FOUT3           ;SEE IF THAT DOES IT.
                                ;THIS ALWAYS GOES.
FOUT9:  JSR     DIV10           ;MAKE IT SMALLER.
        INC     DECCNT
        BNE     FOUT4           ;SEE IF THAT DOES IT.
                                ;THIS ALWAYS GOES.

FOUT5:  JSR     FADDH           ;ADD A HALF TO ROUND UP.
BIGGES: JSR     QINT
        LDX     #$01            ;DECIMAL POINT COUNT.
        LDA     DECCNT
        CLC
        ADC     #3*ADDPRC+7     ;SHOULD NUMBER BE PRINTED IN E NOTATION?
                                ;IE, IS NUMBER .LT. .01 ?
        BMI     FOUTPI          ;YES.
        CMP     #3*ADDPRC+8     ;IS IT .GT. 999999 (999999999)?
        BCS     FOUT6           ;YES. USE E NOTATION.
        ADC     #$FF            ;NUMBER OF PLACES BEFORE DECIMAL POINT.
        TAX                     ;PUT INTO ACCX.
        LDA     #$02            ;NO E NOTATION.
FOUTPI: SEC
FOUT6:  SBC     #$02            ;EFFECTIVELY ADD 5 TO ORIG EXP.
        STA     TENEXP          ;THAT IS THE EXPONENT TO PRINT.
        STX     DECCNT          ;NUMBER OF DECIMAL PLACES.
        TXA
        BEQ     FOUT39
        BPL     FOUT8           ;SOME PLACES BEFORE DEC PNT.
FOUT39: LDY     FBUFPT          ;GET POINTER TO OUTPUT.
        LDA     #'.'            ;PUT IN "."
        INY
        STA     FBUFFR-1,Y
        TXA
        BEQ     FOUT16
        LDA     #'0'            ;GET THE ENSUING ZERO.
        INY
        STA     FBUFFR-1,Y
FOUT16: STY     FBUFPT          ;SAVE FOR LATER.
FOUT8:  LDY     #$00
FOUTIM: LDX     #$80            ;FIRST PASS THRU, ACCX HAS MSB SET.
FOUT2:  LDA     FACLO
        CLC
        ADC     FOUTBL+2+ADDPRC,Y
        STA     FACLO
        LDA     FACMO
        ADC     FOUTBL+1+ADDPRC,Y
        STA     FACMO
        LDA     FACMOH
        ADC     FOUTBL+1,Y
        STA     FACMOH
        LDA     FACHO
        ADC     FOUTBL,Y
        STA     FACHO
        INX                     ;IT WAS DONE YET ANOTHER TIME.
        BCS     FOUT41
        BPL     FOUT2
        BMI     FOUT40
FOUT41: BMI     FOUT2
FOUT40: TXA
        BCC     FOUTYP          ;CAN USE ACCA AS IS.
        EOR     #$FF            ;FIND 11.-[A].
        ADC     #$0A            ;C IS STILL ON TO COMPLETE NEGATION.
                                ;AND WILL ALWAYS BE ON AFTER.
FOUTYP: ADC     #'0'-1          ;GET A CHARACTER TO PRINT.
        INY
        INY
        INY
        INY
        STY     FDECPT
        LDY     FBUFPT
        INY                     ;POINT TO PLACE TO STORE OUTPUT.
        TAX
        AND     #$7F            ;GET RID OF MSB.
        STA     FBUFFR-1,Y
        DEC     DECCNT
        BNE     STXBUF          ;NOT TIME FOR DP YET.
        LDA     #'.'
        INY
        STA     FBUFFR-1,Y      ;STORE DP.
STXBUF: STY     FBUFPT          ;STORE PNTR FOR LATER.
        LDY     FDECPT
FOUTCM: TXA                     ;COMPLEMENT ACCX
        EOR     #$FF            ;COMPLEMENT ACCA.
        AND     #$80            ;SAVE ONLY MSB.
        TAX
        CPY     #FDCEND-FOUTBL
        BEQ     FOULDY
        CPY     #TIMEND-FOUTBL
        BNE     FOUT2           ;CONTINUE WITH OUTPUT.
FOULDY: LDY     FBUFPT          ;GET BACK OUTPUT PNTR.
FOUT11: LDA     FBUFFR-1,Y      ;REMOVE TRAILING ZEROES.
        DEY
        CMP     #'0'
        BEQ     FOUT11
        CMP     #'.'
        BEQ     FOUT12          ;RUN INTO DP. STOP.
        INY                     ;SOMETHING ELSE. SAVE IT.
FOUT12: LDA     #'+'
        LDX     TENEXP
        BEQ     FOUT17          ;NO EXPONENT TO OUTPUT.
        BPL     FOUT14
        LDA     #$00
        SEC
        SBC     TENEXP
        TAX
        LDA     #'-'            ;EXPONENT IS NEGATIVE.
FOUT14: STA     FBUFFR-1+2,Y    ;STORE SIGN OF EXP
        LDA     #'E'
        STA     FBUFFR-1+1,Y    ;STORE THE "E" CHARACTER.
        TXA
        LDX     #'0'-1
        SEC
FOUT15: INX                     ;MOVE CLOSER TO OUTPUT VALUE.
        SBC     #$0A            ;SUBTRACT 10.
        BCS     FOUT15          ;NOT NEGATIVE YET.
        ADC     #'0'+10         ;GET SECOND OUTPUT CHARACTER.
        STA     FBUFFR-1+4,Y    ;STORE HIGH DIGIT.
        TXA
        STA     FBUFFR-1+3,Y    ;STORE  LOW DIGIT.
        LDA     #$00            ;PUT IN TERMINATOR.
        STA     FBUFFR-1+5,Y
        BEQA    FOUT20          ;RETURN. (ALWAYS BRANCHES).
FOUT19: STA     FBUFFR-1,Y      ;STORE THE CHARACTER.
FOUT17: LDA     #$00            ;A TERMINATOR.
        STA     FBUFFR-1+1,Y
FOUT20: LDWDI   FBUFFR
FPWRRT: RTS                     ;ALL DONE.
FHALF:  .BYTE 128       ;1/2
        .BYTE 0
ZERO:   .BYTE 0
        .BYTE 0
.BYTE 0

;POWER OF TEN TABLE

FOUTBL: .BYTE 250       ;-100,000,000
        .BYTE 10
        .BYTE 31
        .BYTE 0
        .BYTE 0 ;10,000,000
        .BYTE 152
        .BYTE 150
        .BYTE 128
        .BYTE 255       ;-1,000,000
        .BYTE 240
        .BYTE 189
        .BYTE 192
        .BYTE 0 ;100,000
        .BYTE 1
        .BYTE 134
        .BYTE 160
        .BYTE 255       ;-10,000
        .BYTE 255
        .BYTE 216
        .BYTE 240
        .BYTE 0 ;1000
        .BYTE 0
        .BYTE 3
        .BYTE 232
        .BYTE 255       ;-100
        .BYTE 255
        .BYTE 255
        .BYTE 156
        .BYTE 0 ;10
        .BYTE 0
        .BYTE 0
        .BYTE 10
        .BYTE 255       ;-1
        .BYTE 255
        .BYTE 255
        .BYTE 255
FDCEND:
        .BYTE 255       ; -2160000 FOR TIME CONVERTER.
        .BYTE 223
        .BYTE 10
        .BYTE 128
        .BYTE 0 ; 216000
        .BYTE 3
        .BYTE 75
        .BYTE 192
        .BYTE 255       ; -36000
        .BYTE 255
        .BYTE 115
        .BYTE 96
        .BYTE 0 ; 3600
        .BYTE 0
        .BYTE 14
        .BYTE 16
        .BYTE 255       ; -600
        .BYTE 255
        .BYTE 253
        .BYTE 168
        .BYTE 0 ; 60
        .BYTE 0
        .BYTE 0
        .BYTE 60
TIMEND:

; SUBTTL        EXPONENTIATION AND SQUARE ROOT FUNCTION.
        ;SQUARE ROOT FUNCTION --- SQR(A)
        ;USE SQR(X)=X^.5
SQR:    JSR     MOVAF           ;MOVE FAC INTO ARG.
        LDWDI   FHALF
        JSR     MOVFM           ;PUT MEMORY INTO FAC.
                                ;LAST THING FETCHED IS FACEXP. INTO ACCX.
;       JMP     FPWRT           ;FALL INTO FPWRT.

        ;EXPONENTIATION ---  X^Y.
        ;N.B.  0^0=1
        ;FIRST CHECK IF Y=0. IF SO, THE RESULT IS 1.
        ;NEXT CHECK IF X=0. IF SO THE RESULT IS 0.
        ;THEN CHECK IF X.GT.0. IF NOT CHECK THAT Y IS AN INTEGER.
        ;IF SO, NEGATE X, SO THAT LOG DOESN'T GIVE FCERR.
        ;IF X IS NEGATIVE AND Y IS ODD, NEGATE THE RESULT
        ;RETURNED BY EXP.
        ;TO COMPUTE THE RESULT USE X^Y=EXP((Y*LOG(X)).
FPWRT:  BEQ     EXP             ;IF FAC=0, JUST EXPONENTIATE THAT.
        LDA     ARGEXP          ;IS X=0?
        BNE     FPWRT1
        JMP     ZEROF1          ;ZERO FAC.
FPWRT1: LDXYI   TEMPF3          ;SAVE FOR LATER IN A TEMP.
        JSR     MOVMF
        ;Y=0 ALREADY. GOOD IN CASE NO ONE CALLS INT.
        LDA     ARGSGN
        BPL     FPWR1           ;NO PROBLEMS IF X.GT.0.
        JSR     INT             ;INTEGERIZE THE FAC.
        LDWDI   TEMPF3          ;GET ADDR OF COMPERAND.
        JSR     FCOMP           ;EQUAL?
        BNE     FPWR1           ;LEAVE X NEG. LOG WILL BLOW HIM OUT.
                                ;A=-1 AND Y IS IRRELEVANT.
        TYA                     ;NEGATE X. MAKE POSITIVE.
        LDY     INTEGR          ;GET EVENNESS.
FPWR1:  JSR     MOVFA1          ;ALTERNATE ENTRY POINT.
        TYA
        PHA                     ;SAVE EVENNESS FOR LATER.
        JSR     LOG             ;FIND LOG.
        LDWDI   TEMPF3          ;MULTIPLY FAC TIMES LOG(X).
        JSR     FMULT
        JSR     EXP             ;EXPONENTIATE THE FAC.
        PLA
        LSR     A               ;IS IT EVEN?
        BCC     NEGRTS          ;YES. OR X.GT.0.
        ;NEGATE THE NUMBER IN FAC.
NEGOP:  LDA     FACEXP
        BEQ     NEGRTS
        COM     FACSGN
NEGRTS: RTS

; SUBTTL        EXPONENTIATION FUNCTION.
        ;FIRST SAVE THE ORIGINAL ARGUMENT AND MULTIPLY THE FAC BY
        ;LOG2(E). THE RESULT IS USED TO DETERMINE IF OVERFLOW
        ;WILL OCCUR SINCE EXP(X)=2^(X*LOG2(E)) WHERE
        ;LOG2(E)=LOG(E) BASE 2. THEN SAVE THE INTEGER PART OF
        ;THIS TO SCALE THE ANSWER AT THE END. SINCE
        ;2^Y=2^INT(Y)*2^(Y-INT(Y)) AND 2^INT(Y) IS EASY TO COMPUTE.
        ;NOW COMPUTE 2^(X*LOG2(E)-INT(X*LOG2(E)) BY
        ;P(LN(2)*(INT(X*LOG2(E))+1)-X) WHERE P IS AN APPROXIMATION
        ;POLYNOMIAL. THE RESULT IS THEN SCALED BY THE POWER OF 2
        ;PREVIOUSLY SAVED.

LOGEB2: .BYTE 129                       ;LOG(E) BASE 2.
        .BYTE 56
        .BYTE 170
        .BYTE 59
.BYTE 41



EXPCON: .BYTE 7 ;DEGREE-1
        .BYTE 113       ; .000021498763697
        .BYTE 52
        .BYTE 88
        .BYTE 62
        .BYTE 86
        .BYTE 116       ; .00014352314036
        .BYTE 22
        .BYTE 126
        .BYTE 179
        .BYTE 27
        .BYTE 119       ; .0013422634824
        .BYTE 47
        .BYTE 238
        .BYTE 227
        .BYTE 133
        .BYTE 122       ; .0096140170119
        .BYTE 29
        .BYTE 132
        .BYTE 28
        .BYTE 42
        .BYTE 124       ; .055505126860
        .BYTE 99
        .BYTE 89
        .BYTE 88
        .BYTE 10
        .BYTE 126       ; .24022638462
        .BYTE 117
        .BYTE 253
        .BYTE 231
        .BYTE 198
        .BYTE 128       ; .69314718608
        .BYTE 49
        .BYTE 114
        .BYTE 24
        .BYTE 16
        .BYTE 129       ; 1.0
        .BYTE 0
        .BYTE 0
        .BYTE 0
        .BYTE 0

EXP:
        LDWDI   LOGEB2          ;MULTIPLY BY LOG(E) BASE 2.
        JSR     FMULT
        LDA     FACOV
        ADC     #$50
        BCC     STOLD
        JSR     INCRND
STOLD:  STA     OLDOV
        JSR     MOVEF           ;TO SAVE IN ARG WITHOUT ROUND.
        LDA     FACEXP
        CMP     #$88            ;IF ABS(FAC) .GE. 128, TOO BIG.
        BCC     EXP1
GOMLDV: JSR     MLDVEX          ;OVERFLOW OR OVERFLOW.
EXP1:   JSR     INT
        LDA     INTEGR  ;GET LOW PART.
        CLC
        ADC     #$81
        BEQ     GOMLDV          ;OVERFLOW OR OVERFLOW !!
        SEC
        SBC     #$01            ;SUBTRACT 1.
        PHA                     ;SAVE A WHILE.
        LDX     #4+ADDPRC       ;PREP TO SWAP FAC AND ARG.
SWAPLP: LDA     ARGEXP,X
        LDY     FACEXP,X
        STA     FACEXP,X
        STY     ARGEXP,X
        DEX
        BPL     SWAPLP
        LDA     OLDOV
        STA     FACOV
        JSR     FSUBT
        JSR     NEGOP           ;NEGATE FAC.
        LDWDI   EXPCON
        JSR     POLY
        CLR     ARISGN          ;MULTIPLY BY POSITIVE 1.0.
        PLA                     ;GET SCALE FACTOR.
        JSR     MLDEXP          ;MODIFY FACEXP AND CHECK FOR OVERFLOW.
        RTS                     ;HAS TO DO JSR DUE TO PULAS IN MULDIV.


; SUBTTL        POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR.
        ;EVALUATE P(X^2)*X
        ;POINTER TO DEGREE IS IN [Y,A].
        ;THE CONSTANTS FOLLOW THE DEGREE.
        ;FOR X=FAC, COMPUTE:
        ; C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1)
POLYX:  STWD    POLYPT          ;RETAIN POLYNOMIAL POINTER FOR LATER.
        JSR     MOV1F           ;SAVE FAC IN FACTMP.
        LDA     #TEMPF1
        JSR     FMULT           ;COMPUTE X^2.
        JSR     POLY1           ;COMPUTE P(X^2).
        LDWDI   TEMPF1
        JMP     FMULT           ;MULTIPLY BY FAC AGAIN.

        ;POLYNOMIAL EVALUATOR.
        ;POINTER TO DEGREE IS IN [Y,A].
        ;COMPUTE:
        ; C0+C1*X+C2*X^2+C3*X^3+C4*X^4+...+C(N-1)*X^(N-1)+C(N)*X^N.
POLY:   STWD    POLYPT
POLY1:  JSR     MOV2F           ;SAVE FAC.
        LDA     (POLYPT),Y
        STA     DEGREE
        LDY     POLYPT
        INY
        TYA
        BNE     POLY3
        INC     POLYPT+1
POLY3:  STA     POLYPT
        LDY     POLYPT+1
POLY2:  JSR     FMULT
        LDWD    POLYPT          ;GET CURRENT POINTER.
        CLC
        ADC     #4+ADDPRC
        BCC     POLY4
        INY
POLY4:  STWD    POLYPT
        JSR     FADD            ;ADD IN CONSTANT.
        LDWDI   TEMPF2          ;MULTIPLY THE ORIGINAL FAC.
        DEC     DEGREE          ;DONE?
        BNE     POLY2
RANDRT: RTS                     ;YES.

        ;PSUEDO-RANDOM NUMBER GENERATOR.
        ;IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED.
        ;IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS
        ;STARTED USING THE ARGUMENT.
        ;   TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE,
        ;MULTIPLY THE PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT
        ;AND ADD IN ANOTHER RANDOM CONSTANT. THE THEN HO
        ;AND LO BYTES ARE SWITCHED, THE EXPONENT IS PUT WHERE
        ;IT WILL BE SHIFTED IN BY NORMAL, AND THE EXPONENT IN THE FAC
        ;IS SET TO 200 SO THE RESULT WILL BE LESS THAN 1. THIS
        ;IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
        ;THE HO AND LOW BYTES WERE SWITCHED SO THERE WILL BE A
        ;RANDOM CHANCE OF GETTING A NUMBER LESS THAN OR GREATER
        ;THAN .5 .

RMULZC: .BYTE 152
        .BYTE 53
        .BYTE 68
        .BYTE 122
RADDZC: .BYTE 104
        .BYTE 40
        .BYTE 177
        .BYTE 70

RND:    JSR     SIGN            ;GET SIGN INTO ACCX.
        BMI     RND1            ;START NEW SEQUENCE IF NEGATIVE.
        BNE     QSETNR
                ;TIMERS ARE AT 9044(L0),45(HI),48(LO),49(HI) HEX.
                ;FIRST TWO ARE ALWAYS FREE RUNNING.
                ;SECOND PAIR IS NOT. LO IS FREER THAN HI THEN.
                ;SO ORDER IN FAC IS 44,48,45,49.
        LDA     CQHTIM
        STA     FACHO
        LDA     CQHTIM+4
        STA     FACMOH
        LDA     CQHTIM+1
        STA     FACMO
        LDA     CQHTIM+5
        STA     FACLO
        JMP     STRNEX
QSETNR: LDWDI   RNDX            ;GET LAST ONE INTO FAC.
        JSR     MOVFM
        LDWDI   RMULZC          ;MULTIPLY BY RANDOM CONSTANT.
        JSR     FMULT
        LDWDI   RADDZC
        JSR     FADD            ;ADD RANDOM CONSTANT.
RND1:   LDX     FACLO
        LDA     FACHO
        STA     FACLO
        STX     FACHO           ;REVERSE HO AND LO.
        LDX     FACMOH
        LDA     FACMO
        STA     FACMOH
        STX     FACMO
STRNEX: CLR     FACSGN          ;MAKE NUMBER POSITIVE.
        LDA     FACEXP          ;PUT EXP WHERE IT WILL
        STA     FACOV           ;BE SHIFTED IN BY NORMAL.
        LDA     #$80
        STA     FACEXP          ;MAKE RESULT BETWEEN 0 AND 1.
        JSR     NORMAL          ;NORMALIZE.
        LDXYI   RNDX
GMOVMF: JMP     MOVMF           ;PUT NEW ONE INTO MEMORY.

; SUBTTL        SINE, COSINE AND TANGENT FUNCTIONS.
        ;COSINE FUNCTION.
        ;USE COS(X)=SIN(X+PI/2)
COS:    LDWDI   PI2             ;PNTR TO PI/2.
        JSR     FADD            ;ADD IT IN.
                                ;FALL INTO SIN.


        ;SINE FUNCTION.
        ;USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV.
        ;THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED
        ;BECAUSE SIN(X+2*PI)=SIN(X). THEN THE ARGUMENT CAN BE COMPARED
        ;WITH PI/2 BY COMPARING THE RESULT OF THE DIVISION
        ;WITH PI/2/(2*PI)=1/4.
        ;IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS
        ;I OR IV. AN APPROXIMATION POLYNOMIAL IS THEN USED TO
        ;COMPUTE SIN(X).
SIN:    JSR     MOVAF
        LDWDI   TWOPI           ;GET PNTR TO DIVISOR.
        LDX     ARGSGN          ;GET SIGN OF RESULT.
        JSR     FDIVF
        JSR     MOVAF           ;GET RESULT INTO ARG.
        JSR     INT             ;INTEGERIZE FAC.
        CLR     ARISGN          ;ALWAYS HAVE THE SAME SIGN.
        JSR     FSUBT           ;KEEP ONLY THE FRACTIONAL PART.
        LDWDI   FR4             ;GET PNTR TO 1/4.
        JSR     FSUB            ;COMPUTE 1/4-FAC.
        LDA     FACSGN          ;SAVE SIGN FOR LATER.
        PHA
        BPL     SIN1            ;FIRST QUADRANT.
        JSR     FADDH           ;ADD 1/2 TO FAC.
        LDA     FACSGN          ;SIGN IS NEGATIVE?
        BMI     SIN2
        COM     TANSGN          ;QUADRANTS II AND III COME HERE.
SIN1:   JSR     NEGOP           ;IF POSITIVE, NEGATE IT.
SIN2:   LDWDI   FR4             ;POINTER TO 1/4.
        JSR     FADD            ;ADD IT IN.
        PLA                     ;GET ORIGINAL QUADRANT.
        BPL     SIN3
        JSR     NEGOP           ;IF NEGATIVE, NEGATE RESULT.
SIN3:   LDWDI   SINCON
GPOLYX: JMP     POLYX           ;DO APPROXIMATION POLYNOMIAL.


        ;TANGENT FUNCTION.
TAN:    JSR     MOV1F           ;MOVE FAC INTO TEMPORARY.
        CLR     TANSGN          ;REMEMBER WHETHER TO NEGATE.
        JSR     SIN             ;COMPUTE THE SIN.
        LDXYI   TEMPF3
        JSR     GMOVMF          ;PUT SIGN INTO OTHER TEMP.
        LDWDI   TEMPF1
        JSR     MOVFM           ;PUT THIS MEMORY LOC INTO FAC.
        CLR     FACSGN          ;START OFF POSITIVE.
        LDA     TANSGN
        JSR     COSC            ;COMPUTE COSINE.
        LDWDI   TEMPF3          ;ADDRESS OF SINE VALUE.
GFDIV:  JMP     FDIV            ;DIVIDE SINE BY COSINE AND RETURN.
COSC:   PHA
        JMP     SIN1

PI2:    .BYTE 129       ;PI/2
        .BYTE 73
        .BYTE 15
        .BYTE 219-ADDPRC
.BYTE 162
TWOPI:  .BYTE 131       ;2*PI.
        .BYTE 73
        .BYTE 15
        .BYTE 219-ADDPRC
.BYTE 162
FR4:    .BYTE 127       ;1/4
        .BYTE 0
        .BYTE 0
        .BYTE 0
.BYTE 0

SINCON: .BYTE 5         ;DEGREE-1.
        .BYTE 132       ; -14.381383816
        .BYTE 230
        .BYTE 26
        .BYTE 45
        .BYTE 27
        .BYTE 134       ; 42.07777095
        .BYTE 40
        .BYTE 7
        .BYTE 251
        .BYTE 248
        .BYTE 135       ; -76.704133676
        .BYTE 153
        .BYTE 104
        .BYTE 137
        .BYTE 1
        .BYTE 135       ; 81.605223690
        .BYTE 35
        .BYTE 53
        .BYTE 223
        .BYTE 225
        .BYTE 134       ; -41.34170209
        .BYTE 165
        .BYTE 93
        .BYTE 231
        .BYTE 40
        .BYTE 131       ; 6.2831853070
        .BYTE 73
        .BYTE 15
        .BYTE 218
        .BYTE 162
        .BYTE 161       ; 7.2362932E7
        .BYTE 84
        .BYTE 70
        .BYTE 143
        .BYTE 19
        .BYTE 143       ; 73276.2515
        .BYTE 82
        .BYTE 67
        .BYTE 137
        .BYTE 205
; SUBTTL        ARCTANGENT FUNCTION.
        ;USE IDENTITIES TO GET ARG BETWEEN 0 AND 1 AND THEN USE AN
        ;APPROXIMATION POLYNOMIAL TO COMPUTE ARCTAN(X).
ATN:    LDA     FACSGN          ;WHAT IS SIGN?
        PHA                     ;(MEANWHILE SAVE FOR LATER.)
        BPL     ATN1
        JSR     NEGOP           ;IF NEGATIVE, NEGATE FAC.
                                ;USE ARCTAN(X)=-ARCTAN(-X) .
ATN1:   LDA     FACEXP
        PHA                     ;SAVE THIS TOO FOR LATER.
        CMP     #$81            ;SEE IF FAC .GE. 1.0 .
        BCC     ATN2            ;IT IS LESS THAN 1.
        LDWDI   FONE            ;GET PNTR TO 1.0 .
        JSR     FDIV            ;COMPUTE RECIPROCAL.
                                ;USE ARCTAN(X)=PI/2-ARCTAN(1/X) .
ATN2:   LDWDI   ATNCON          ;PNTR TO ARCTAN CONSTANTS.
        JSR     POLYX
        PLA
        CMP     #$81            ;WAS ORIGINAL ARGUMENT .LT. 1 ?
        BCC     ATN3            ;YES.
        LDWDI   PI2
        JSR     FSUB            ;SUBTRACT ARCTAGN FROM PI/2.
ATN3:   PLA                     ;WAS ORIGINAL ARGUMENT POSITIVE?
        BPL     ATN4            ;YES.
        JMP     NEGOP           ;IF NEGATIVE, NEGATE RESULT.
ATN4:   RTS                     ;ALL DONE.


ATNCON: .BYTE 11        ;DEGREE-1.
        .BYTE 118       ; -.0006847939119
        .BYTE 179
        .BYTE 131
        .BYTE 189
        .BYTE 211
        .BYTE 121       ; .004850942156
        .BYTE 30
        .BYTE 244
        .BYTE 166
        .BYTE 245
        .BYTE 123       ; -.01611170184
        .BYTE 131
        .BYTE 252
        .BYTE 176
        .BYTE 16
        .BYTE 124       ; .03420963805
        .BYTE 12
        .BYTE 31
        .BYTE 103
        .BYTE 202
        .BYTE 124       ; -.05427913276
        .BYTE 222
        .BYTE 83
        .BYTE 203
        .BYTE 193
        .BYTE 125       ; .07245719654
        .BYTE 20
        .BYTE 100
        .BYTE 112
        .BYTE 76
        .BYTE 125       ; -.08980239538
        .BYTE 183
        .BYTE 234
        .BYTE 81
        .BYTE 122
        .BYTE 125       ; .1109324134
        .BYTE 99
        .BYTE 48
        .BYTE 136
        .BYTE 126
        .BYTE 126       ; -.1428398077
        .BYTE 146
        .BYTE 68
        .BYTE 153
        .BYTE 58
        .BYTE 126       ; .1999991205
        .BYTE 76
        .BYTE 204
        .BYTE 145
        .BYTE 199
        .BYTE 127       ; -.3333333157
        .BYTE 170
        .BYTE 170
        .BYTE 170
        .BYTE 19
        .BYTE 129       ; 1.0
        .BYTE 0
        .BYTE 0
        .BYTE 0
        .BYTE 0
; SUBTTL        SYSTEM INITIALIZATION CODE.
; THIS INITIALIZES THE BASIC INTERPRETER FOR THE M6502 AND SHOULD BE
; LOCATED WHERE IT WILL BE WIPED OUT IN RAM IF CODE IS ALL IN RAM.

                                ;RESTARTING INIT
INITAT: INC     CHRGET+7        ;INCREMENT THE WHOLE TXTPTR.
        BNE     CHZGOT
        INC     CHRGET+8
CHZGOT: LDA     60000           ;A LOAD WITH AN EXT ADDR.
        CMP     #':'            ;IS IT A ":"?
        BCS     CHZRTS          ;IT IS .GE. ":"
        CMP     #' '            ;SKIP SPACES.
        BEQ     INITAT
        SEC
        SBC     #'0'            ;ALL CHARS .GT. "9" HAVE RET'D SO
        SEC
        SBC     #256-'0'                ;SEE IF NUMERIC.
                                ;TURN CARRY ON IF NUMERIC.
                                ;ALSO, SETZ IF NULL.
CHZRTS: RTS                     ;RETURN TO CALLER.

        .BYTE 128                       ;LOADED OR FROM ROM.
        .BYTE 79                        ;THE INITIAL RANDOM NUMBER.
        .BYTE 199
        .BYTE 82
.BYTE 88
INIT:
        LDX     #STKEND-256
        TXS
        LDA     #76             ;JMP INSTRUCTION.
        STA     JMPER
        STA     USRPOK
        LDWDI   FCERR
        STWD    USRPOK+1
        LDA     #LINLEN         ;THESE MUST BE NON-ZERO SO CHEAD WILL
        STA     LINWID          ;WORK AFTER MOVING A NEW LINE IN BUF
                                ;INTO THE PROGRAM
        LDA     #NCMPOS
        STA     NCMWID
        LDX     #RNDX+4-CHRGET
MOVCHG: LDA     INITAT-1,X
        STA     CHRGET-1,X      ;MOVE TO RAM.
        DEX
        BNE     MOVCHG
        LDA     #STRSIZ
        STA     FOUR6
        TXA                     ;SET CONST IN RAM.
        STA     BITS
        STA     CHANNL
        STA     LASTPT+1
        PHA                     ;PUT ZERO AT THE END OF THE STACK
                                ;SO FNDFOR WILL STOP
        STA     CNTWFL          ;BE TALKATIVE.
        INX                     ;MAKE [X]=1
        STX     BUF-3           ;SET PRE-BUF BYTES NON-ZERO FOR CHEAD
        STX     BUF-4
        LDX     #TEMPST
        STX     TEMPPT          ;SET UP STRING TEMPORARIES.
        LDY     #RAMLOC/256
        STWD    TXTTAB          ;SET UP START OF PROGRAM LOCATION
        STWD    LINNUM
        TAY
LOOPMM: INC     LINNUM
        BNE     LOOPM1
        INC     LINNUM+1
        BMI     USEDEC
LOOPM1: LDA     #85             ;PUT RANDOM INFO INTO MEM.
        STA     (LINNUM),Y
        CMP     (LINNUM),Y              ;WAS IT SAVED?
        BNE     USEDEC          ;NO. THAT IS END OF MEMORY.
        ASL     A               ;LOOKS LIKE IT. TRY ANOTHER.
        STA     (LINNUM),Y
        CMP     (LINNUM),Y              ;WAS IT SAVED?
        BEQ     LOOPMM
USEDEC: LDWD    LINNUM          ;GET SIZE OF MEMORY INPUT.
USEDEF:                         ;HIGHEST ADDRESS.
        STWD    MEMSIZ          ;THIS IS THE SIZE OF MEMORY.
        STWD    FRETOP          ;TOP OF STRINGS TOO.
TTYW:
        LDXYI   RAMLOC
        STXY    TXTTAB
        LDY     #0
        TYA
        STA     (TXTTAB),Y              ;SET UP TEXT TABLE.
        INC     TXTTAB
QROOM:  LDWD    TXTTAB          ;PREPARE TO USE "REASON".
        JSR     REASON
        LDWDI   FREMES
        JSR     STROUT
        LDA     MEMSIZ          ;COMPUTE [MEMSIZ]-[VARTAB].
        SEC
        SBC     TXTTAB
        TAX
        LDA     MEMSIZ+1
        SBC     TXTTAB+1
        JSR     LINPRT          ;TYPE THIS VALUE.
        LDWDI   WORDS           ;MORE BULLSHIT.
        JSR     STROUT
        JSR     SCRTCH          ;SET UP EVERYTHING ELSE.
        JMP     READY
WORDS:  DT" BYTES FREE"
        .BYTE $0D
        .BYTE 0
FREMES: 
        DT"### COMMODORE BASIC ###"
        .BYTE $0D
        .BYTE $0D
        .BYTE 0

